/////////////////////////////////////////////////////////////////////////////
//          File:: ApplManClient.cpp
// Create Author:: Nick Fung
// Create   Date:: 09 Nov 2000
//
//   Description:: ApplManClient class declaration
//
//
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000 by AFE Solutions Ltd.
// All rights reserved.
//
// No portion of this software in any form may be used or reproduced in 
// any manner without written consent from AFE Solutions Ltd.
//
//
// $Date: 10/08/15 3:04p $ 
// $Author: Sulfred_lee $ 

#include "ApplManClient.h"
#include "RpcApplMan.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
extern "C"
{
//	void  * __RPC_USER MIDL_user_allocate(size_t size);
	void __RPC_FAR * __RPC_USER midl_user_allocate(size_t cBytes)
	{
		return((void __RPC_FAR *) malloc(cBytes));
	}

	//void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t t)
	//{
	//	return malloc(t);
	//}

	void __RPC_USER MIDL_user_free( void __RPC_FAR * pPtr)
	{
		free(pPtr);
	}
}

HANDLE gExitEvent=NULL;
BOOL WINAPI ConsoleHandler(DWORD dwCtrlType)
{
	switch( dwCtrlType )
	{
		case CTRL_C_EVENT :			//A CTRL+C signal was received, either from keyboard input or from a signal generated by the GenerateConsoleCtrlEvent function.
		case CTRL_BREAK_EVENT :		//A CTRL+BREAK signal was received, either from keyboard input or from a signal generated by GenerateConsoleCtrlEvent.
		case CTRL_CLOSE_EVENT :		//A signal that the system sends to all processes attached to a console when the user closes the console (either by choosing the Close command from the console window's System menu, or by choosing the End Task command from the Task List).
		case CTRL_SHUTDOWN_EVENT :	//A signal that the system sends to all console processes when the system is shutting down.
			SetEvent(gExitEvent);
			break;
		default :
			break;
	}

	return TRUE;
}

char CApplManClient::m_szFormattedSystemTime[TEMP_BUFFER];
DWORD CApplManClient::m_dwAppId = 0;
BOOL CApplManClient::m_bInstantiated = FALSE;
BOOL CApplManClient::m_bInitialized = FALSE;
BOOL CApplManClient::m_bIsapidllClient = FALSE;
HANDLE CApplManClient::m_hWaitEvent[NUMBER_WAITEVENT];
HANDLE CApplManClient::m_hReplyEvent[NUMBER_REPLYEVENT];
BOOL CApplManClient::m_bExit = FALSE;
BOOL CApplManClient::m_bTraceOn = FALSE;
unsigned char * CApplManClient::m_pszStringBinding = '\0';
ssCriticalSection CApplManClient::m_CS;


CApplManClient::CApplManClient()
{
	if (!m_bInstantiated)
	{	
		memset(m_szFormattedSystemTime, 0, sizeof(m_szFormattedSystemTime));
		memset(m_hWaitEvent, 0, sizeof(HANDLE)*NUMBER_WAITEVENT);
		memset(m_hReplyEvent, 0, sizeof(HANDLE)*NUMBER_REPLYEVENT);
		m_hWaitEvent[SHUTDOWN]=CreateEvent(NULL, FALSE, FALSE, NULL);
		m_bInstantiated = TRUE;
	
		SetConsoleCtrlHandler(ConsoleHandler, TRUE );
		gExitEvent = m_hWaitEvent[SHUTDOWN];
	}
}

CApplManClient::~CApplManClient()
{
	if (m_bInitialized)
	{
		Uninitialize();
	}
	if (m_bInstantiated)
	{
		CloseHandle(m_hWaitEvent[SHUTDOWN]);
		m_hWaitEvent[SHUTDOWN] = NULL;
		m_bInstantiated = FALSE;
	}
}

BOOL CApplManClient::Initialize(DWORD dwAppId, BOOL bIsIsapiDllClient)
{
	if (dwAppId==0)
		return FALSE;
	else
		m_dwAppId = dwAppId;
	
	if (!InitRpcClient())
		return FALSE;

	m_bIsapidllClient = bIsIsapiDllClient;
	char buf[256];
	wsprintf(buf, "PS_%d_CheckAliveCall", dwAppId);
	m_hWaitEvent[CHECKALIVE]=CreateEvent(NULL, FALSE, FALSE, buf);
	wsprintf(buf, "PS_%d_ShutdownCall", dwAppId);
	m_hWaitEvent[REMOTE_SHUTDOWN]=CreateEvent(NULL, FALSE, FALSE, buf);
	wsprintf(buf, "PS_%d_RebuildCall", dwAppId);
	m_hWaitEvent[REBUILD]=CreateEvent(NULL, FALSE, FALSE, buf);
	wsprintf(buf, "PS_%d_TraceOn", dwAppId);
	m_hWaitEvent[TRACEON]=CreateEvent(NULL, FALSE, FALSE, buf);
	wsprintf(buf, "PS_%d_TraceOff", dwAppId);
	m_hWaitEvent[TRACEOFF]=CreateEvent(NULL, FALSE, FALSE, buf);

	wsprintf(buf, "PS_%d_CheckAliveReply", dwAppId);
	m_hReplyEvent[REPLY_CHECKALIVE]=CreateEvent(NULL, FALSE, FALSE, buf);
	wsprintf(buf, "PS_%d_RebuildReply", dwAppId);
	m_hReplyEvent[REPLY_REBUILD]=CreateEvent(NULL, FALSE, FALSE, buf);
	wsprintf(buf, "PS_%d_RebuildComplete", dwAppId);
	m_hReplyEvent[REPLY_REBUILD_COMPLETED]=CreateEvent(NULL, FALSE, FALSE, buf);
	m_bInitialized = CheckEvents();
	return m_bInitialized;
}

void CApplManClient::Uninitialize()
{
	if (m_bInitialized)
	{
		for (int i=CHECKALIVE;i<NUMBER_WAITEVENT;i++)
		{
			CloseHandle(m_hWaitEvent[i]);
			m_hWaitEvent[i]=NULL;
		}
		for (int i=REPLY_CHECKALIVE;i<NUMBER_REPLYEVENT;i++)
		{
			CloseHandle(m_hReplyEvent[i]);
			m_hReplyEvent[i]=NULL;
		}
		UninitRpcClient();
	}
	m_bInitialized = FALSE;
	return;
}

BOOL CApplManClient::CheckEvents()
{
	BOOL bAllSuccess=TRUE;
	for (int i=CHECKALIVE;(i<NUMBER_WAITEVENT)&&(bAllSuccess);i++)
	{
		if (m_hWaitEvent[i]==NULL)
			bAllSuccess=FALSE;
	}

	for (int i=REPLY_CHECKALIVE;(i<NUMBER_REPLYEVENT)&&(bAllSuccess);i++)
	{
		if (m_hReplyEvent[i]==NULL)
			bAllSuccess=FALSE;
	}

	if (!bAllSuccess)
	{
		for (int i=CHECKALIVE;i<NUMBER_WAITEVENT;i++)
		{
			CloseHandle(m_hWaitEvent[i]);
			m_hWaitEvent[i]=NULL;
		}

		for (int i=REPLY_CHECKALIVE;i<NUMBER_REPLYEVENT;i++)
		{
			CloseHandle(m_hReplyEvent[i]);
			m_hReplyEvent[i]=NULL;
		}
	}
	return bAllSuccess;
}

BOOL CApplManClient::InitRpcClient()
{
	RPC_STATUS status;
    unsigned char * pszUuid             = NULL;
    unsigned char * pszProtocolSequence = (unsigned char*)"ncalrpc";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszEndpoint         = (unsigned char*)"Ranma_ApplMan";
    unsigned char * pszOptions          = NULL;
    
    /* Use a convenience function to concatenate the elements of */
    /* the string binding into the proper sequence.              */
    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &m_pszStringBinding);
    if (status) 
	{
        return FALSE;
    }

    /* Set the binding handle that will be used to bind to the server. */
    status = RpcBindingFromStringBinding(m_pszStringBinding,
                                         &ApplMan_IfHandle);
    if (status) 
	{
        return FALSE;
    }

	return TRUE;
}

BOOL CApplManClient::UninitRpcClient()
{
	RPC_STATUS status;
	status = RpcStringFree(&m_pszStringBinding);  // remote calls done; unbind
	if (status) 
	{
		return FALSE;
	}

	status = RpcBindingFree(&ApplMan_IfHandle);  // remote calls done; unbind
	if (status) 
	{
		return FALSE;
	}
	return TRUE;
}

int CApplManClient::WaitForEvents(DWORD dwTimeout)
{
	DWORD dwStatus;
	if (m_bInitialized)
	{
		dwStatus=WaitForMultipleObjects(NUMBER_WAITEVENT, m_hWaitEvent, FALSE, dwTimeout);
	}
	else
	{
		// just wait for SHUTDOWN
		dwStatus=WaitForMultipleObjects(1, m_hWaitEvent, FALSE, dwTimeout);
	}
	switch(dwStatus)
	{
		case WAIT_OBJECT_0+SHUTDOWN:
			return (SHUTDOWN);

		case WAIT_OBJECT_0+CHECKALIVE:
			return (CHECKALIVE);

		case WAIT_OBJECT_0+REMOTE_SHUTDOWN:
			SetEvent(m_hWaitEvent[SHUTDOWN]);
			return (REMOTE_SHUTDOWN);

		case WAIT_OBJECT_0+REBUILD:
			CApplManClient::RebuildStarted();
			return (REBUILD);

		case WAIT_OBJECT_0+TRACEON:
			SetTraceOn();
			return (TRACEON);

		case WAIT_OBJECT_0+TRACEOFF:
			SetTraceOff();
			return (TRACEOFF);

		default:
			return dwStatus;
	}

}
void CApplManClient::SetTraceOn()
{
	m_bTraceOn=TRUE;
}

void CApplManClient::SetTraceOff()
{
	m_bTraceOn=FALSE;
}


void CApplManClient::FormatLog(int iLevel, size_t sizeBuffer, char* pszString)
{
	switch (iLevel)
	{
		case LOG_INFO:
			sprintf_s(pszString, sizeBuffer, "%s\tLOG_INFO\t", GetFormattedSystemTime());
			break;
		case LOG_MAJOR:
			sprintf_s(pszString, sizeBuffer, "%s\tLOG_MAJOR\t", GetFormattedSystemTime());
			break;
		case LOG_FATAL:
			sprintf_s(pszString, sizeBuffer, "%s\tLOG_FATAL\t", GetFormattedSystemTime());
			break;
		case LOG_NORMAL:
			sprintf_s(pszString, sizeBuffer, "%s\tLOG_NORMAL\t", GetFormattedSystemTime());
			break;
		case LOG_ERROR:
			sprintf_s(pszString, sizeBuffer, "%s\tLOG_ERROR\t", GetFormattedSystemTime());
			break;
		default:
			sprintf_s(pszString, sizeBuffer, "%s\tLOG\t", GetFormattedSystemTime());
			break;
	}

}

BOOL CApplManClient::SendLog(int iLevel, char* pszString)
{
	BOOL bRtn;
	m_CS.Enter();
	RpcTryExcept
	{
		bRtn = ::Log(m_dwAppId, iLevel, (unsigned char*)pszString);
	}
	RpcExcept(1)
	{
		char	szString[MESSAGE_LENGTH+TEMP_BUFFER];
		CApplManClient::FormatLog(iLevel, sizeof(szString), szString);
		if (!m_bIsapidllClient)
			printf("[CApplManClient]%s%s\n", szString, pszString);
		else
			TRACE("[CApplManClient]%s%s\n", szString, pszString);
		bRtn = FALSE;
	}
	RpcEndExcept
	m_CS.Leave();
	return bRtn;
}
 
BOOL CApplManClient::Log(int iLevel, LPCTSTR szFormat, ...)
{
	va_list	Args;
	char	szTempBuffer[MESSAGE_LENGTH];
	try
	{
		va_start(Args, szFormat);
		//vsprintf(szTempBuffer, szFormat, Args );		
		_vsnprintf_s(szTempBuffer,MESSAGE_LENGTH-1, _TRUNCATE, szFormat, Args );	
		va_end(Args);
	}
	catch(...)
	{
		strcpy_s( szTempBuffer, "Logger was passed a bad argument list." );
	}
		
	if (m_bInitialized)
	{
		return CApplManClient::SendLog(iLevel, szTempBuffer);
	}
	else
	{
		char	szString[MESSAGE_LENGTH+TEMP_BUFFER];
		CApplManClient::FormatLog(iLevel, sizeof(szString), szString);

		m_CS.Enter();
		if (!m_bIsapidllClient)
			printf("[CApplManClient]%s%s\n",  szString, szTempBuffer);
		else
			TRACE("[CApplManClient]%s%s\n",  szString, szTempBuffer);		
		m_CS.Leave();
	}
	return TRUE;
}

void CApplManClient::FormatTrace(int iLevel, size_t sizeBuffer, char* pszString)
{
	switch (iLevel)
	{
		case TRACE_LEVEL0:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 0\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL1:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 1\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL2:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 2\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL3:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 3\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL4:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 4\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL5:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 5\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL6:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 6\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL7:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 7\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL8:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 8\t", GetFormattedSystemTime());
			break;
		case TRACE_LEVEL9:
			sprintf_s(pszString, sizeBuffer, "%s\tTRACE LEVEL 9\t", GetFormattedSystemTime());
			break;
		default:
			sprintf_s(pszString, sizeBuffer, "%s\tUNCLASSIFIED TRACE LEVEL\t", GetFormattedSystemTime());
			break;
	}
}

BOOL CApplManClient::SendTrace(int iLevel, char* pszString)
{
	BOOL bRtn;
	m_CS.Enter();
	RpcTryExcept
	{
		bRtn = ::Trace(m_dwAppId, (unsigned char*)pszString);
	}
	RpcExcept(1)
	{
		char	szString[MESSAGE_LENGTH+TEMP_BUFFER];
		CApplManClient::FormatTrace(iLevel, sizeof(szString), szString);
		
		if (!m_bIsapidllClient)
			printf("[CApplManClient]%s%s\n",  szString, pszString);
		else
			TRACE("[CApplManClient]%s%s\n",  szString, pszString);		

		bRtn = FALSE;
	}
	RpcEndExcept
	m_CS.Leave();
	return bRtn;
}

BOOL CApplManClient::Trace(int iLevel,  LPCTSTR szFormat, ...)
{
	if (!m_bTraceOn)
		return TRUE;

	va_list			Args;
	char			szTempBuffer[MESSAGE_LENGTH];
	
	try
	{
		va_start(Args, szFormat);
		//vsprintf(szTempBuffer, szFormat, Args );	
		_vsnprintf_s(szTempBuffer,MESSAGE_LENGTH-1, _TRUNCATE, szFormat, Args );	
		
		va_end(Args);
	}
	catch(...)
	{
		strcpy_s( szTempBuffer, "Tracer was passed a bad argument list." );
	}
	szTempBuffer[MESSAGE_LENGTH-1] = 0;
	if (m_bInitialized)
	{
		return CApplManClient::SendTrace(iLevel, szTempBuffer);
	}
	else
	{
		char	szString[MESSAGE_LENGTH+TEMP_BUFFER];
		CApplManClient::FormatTrace(iLevel, sizeof(szString), szString);
		m_CS.Enter();
		if (!m_bIsapidllClient)
			printf("[CApplManClient]%s%s\n",  szString, szTempBuffer);
		else
			TRACE("[CApplManClient]%s%s\n",  szString, szTempBuffer);		
		
		m_CS.Leave();
	}
	return TRUE;
}

BOOL CApplManClient::SendAlert(char* pszString)
{
	BOOL bRtn;
	m_CS.Enter();
	RpcTryExcept
	{
		bRtn = ::Alert(m_dwAppId, (unsigned char*)pszString);
	}
	RpcExcept(1)
	{
		m_CS.Enter();
		if (!m_bIsapidllClient)
			printf("[CApplManClient]%s\tAlert\t%s\n", GetFormattedSystemTime(), pszString);
		else
			TRACE("[CApplManClient]%s\tAlert\t%s\n", GetFormattedSystemTime(), pszString);
		
		
		m_CS.Leave();
		bRtn = FALSE;
	}
	RpcEndExcept
	m_CS.Leave();
	return bRtn;
}

BOOL CApplManClient::Alert(LPCTSTR szFormat, ...)
{
	va_list			Args;
	char			szTempBuffer[MESSAGE_LENGTH];

	try
	{
		va_start(Args, szFormat);
		//vsprintf(szTempBuffer, szFormat, Args );	
		_vsnprintf_s(szTempBuffer,MESSAGE_LENGTH-1, _TRUNCATE, szFormat, Args );	
		va_end(Args);
	}
	catch(...)
	{
		strcpy_s( szTempBuffer, "Alerter was passed a bad argument list." );
	}

	if (m_bInitialized)
	{
		return CApplManClient::SendAlert(szTempBuffer);
	}
	else
	{
		m_CS.Enter();
		if (!m_bIsapidllClient)
			printf("[CApplManClient]%s\tAlert\t%s\n", GetFormattedSystemTime(), szTempBuffer);
		else
			TRACE("[CApplManClient]%s\tAlert\t%s\n", GetFormattedSystemTime(), szTempBuffer);
		m_CS.Leave();
	}
	return TRUE;
}

BOOL CApplManClient::IsTraceOn()
{
	return m_bTraceOn;
}

void CApplManClient::AckAlive()
{
	if (m_bInitialized)
	{
		::SetEvent(m_hReplyEvent[REPLY_CHECKALIVE]);
	}
}

void CApplManClient::RebuildStarted()
{
	if (m_bInitialized)
	{
		::SetEvent(m_hReplyEvent[REPLY_REBUILD]);
	}
}

void CApplManClient::RebuildCompleted()
{
	if (m_bInitialized)
	{
		::SetEvent(m_hReplyEvent[REPLY_REBUILD_COMPLETED]);
	}
}

void CApplManClient::SetDataCtrlStatus(long lDCStatus)
{
	if (m_bInitialized)
	{
		RpcTryExcept
		{
			::SetDataCtrlStatus(m_dwAppId, lDCStatus);
		}
		RpcExcept(1)
		{
		}
		RpcEndExcept
	}
}
