/////////////////////////////////////////////////////////////////////////////
//          File:: Definition.h
// Create Author:: Sammy Ha
// Create   Date:: 15 September 2000
//
//   Description:: definition classes and tables for fidDatabase and data type 
//
//
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2000 by AFE Solutions Ltd.
// All rights reserved.
//
// No portion of this software in any form may be used or reproduced in 
// any manner without written consent from AFE Solutions Ltd.
//
//
#ifndef __Definition_h__
#define __Definition_h__
#pragma warning( once : 4996 )

//#include "Definition.h"
#include <math.h>
#include "ssCommon.h"
#include "ssUtf8String.h"
#include "currency.h"
#include "market.h"
//#include "ApplManClient.h"
#define INVALID_FID			-1
#define MAX_FID_NAME		32

namespace NGN2{

typedef enum {
	MGT_LOGONREQUEST		=	1,
	MGT_LOGONRESPONSE		=	2,
	MGT_ADDWATCH			=	3,
	MGT_DELETEWATCH			=	4,
	MGT_SNAPSHOT 			=	5,
	MGT_DATAPERMISSION		=	6,
	MGT_FORCEUPDATE			=	8,
	MGT_UPDATE 				=	9,
	MGT_VERIFYSYNC			=	10,
	MGT_CLOSINGRUN	 		=	11,
	MGT_DROP		 		=	12,
	MGT_INTRADAYREBUILD 	=	13,
	MGT_INTRADAYCORRECTION 	=	14,
	MGT_ALIVE				=	17,
	MGT_RAISEHANDREQUEST 	=	18,
	MGT_RAISEHANDREPLY		=	19,
	MGT_SYSTEMMESSAGE		=	20,
}MSGTYPE;

typedef enum {
	MKT_ASE 	=	1,
	MKT_NYS 	=	2,
	MKT_BOS 	=	3,
	MKT_CIN 	=	4,
	MKT_PSE 	=	5,
	MKT_XPH 	=	6,
	MKT_THM 	=	7,
	MKT_MID 	=	8,
	MKT_NYQ 	=	9,
	MKT_TOR 	=	10,
	MKT_MON 	=	11,
	MKT_VAN 	=	12,
	MKT_ALB 	=	13,
	MKT_AOE 	=	14,
	MKT_NYO 	=	15,
	MKT_PHO 	=	16,
	MKT_PAO 	=	17,
	MKT_WCB 	=	18,
	MKT_ASQ 	=	19,
	MKT_CME 	=	20,
	MKT_IMM 	=	21,
	MKT_IOM 	=	22,
	MKT_CBT 	=	23,
	MKT_MAC 	=	24,
	MKT_WPG 	=	25,
	MKT_MGE 	=	26,
	MKT_PBT 	=	27,
	MKT_CMX 	=	28,
	MKT_CSC 	=	29,
	MKT_NYC 	=	30,
	MKT_NYM 	=	31,
	MKT_M32 	=	32,
	MKT_CSO 	=	33,
	MKT_CEO 	=	34,
	MKT_SHC 	=	35,
	MKT_NYF 	=	36,
	MKT_TFE 	=	37,
	MKT_MIO 	=	38,
	MKT_NMS 	=	39,
	MKT_TOE 	=	40,
	MKT_MOE 	=	41,
	MKT_VAO 	=	42,
	MKT_NAS 	=	43,
	MKT_MDM 	=	44,
	MKT_SCE 	=	45,
	MKT_BSQ 	=	46,
	MKT_M47 	=	47,
	MKT_WCQ 	=	48,
	MKT_CRC 	=	49,
	MKT_KBT 	=	50,
	MKT_SOM 	=	51,
	MKT_M52 	=	52,
	MKT_M53 	=	53,
	MKT_MIF 	=	54,
	MKT_JSF 	=	55,
	MKT_TCE 	=	56,
	MKT_TFF 	=	57,
	MKT_EME 	=	58,
	MKT_HOM 	=	59,
	MKT_FOM 	=	60,
	MKT_FIR 	=	61,
	MKT_ATH 	=	62,
	MKT_SFF 	=	63,
	MKT_LSE 	=	64,
	MKT_JNB 	=	65,
	MKT_LIF 	=	66,
	MKT_TLV 	=	67,
	MKT_CPH 	=	68,
	MKT_OSL 	=	69,
	MKT_STO 	=	70,
	MKT_M71 	=	71,
	MKT_LUX 	=	72,
	MKT_BRU 	=	73,
	MKT_PAR 	=	74,
	MKT_MAD 	=	75,
	MKT_BAR 	=	76,
	MKT_AMS 	=	77,
	MKT_EOE 	=	78,
	MKT_ATA 	=	79,
	MKT_VIE 	=	80,
	MKT_DUS 	=	81,
	MKT_FRA 	=	82,
	MKT_HAM 	=	83,
	MKT_MUN 	=	84,
	MKT_ZRH 	=	85,
	MKT_GVA 	=	86,
	MKT_BSL 	=	87,
	MKT_MIL 	=	88,
	MKT_M89 	=	89,
	MKT_M90 	=	90,
	MKT_NZE 	=	91,
	MKT_HKG 	=	92,
	MKT_SIM 	=	93,
	MKT_KLC 	=	94,
	MKT_M95 	=	95,
	MKT_M96 	=	96,
	MKT_M97 	=	97,
	MKT_M98 	=	98,
	MKT_LME 	=	99,
	MKT_M100 	=	100,
	MKT_LCE 	=	101,
	MKT_M102 	=	102,
	MKT_M103 	=	103,
	MKT_M104 	=	104,
	MKT_SFE 	=	105,
	MKT_TYO 	=	106,
	MKT_NGO 	=	107,
	MKT_SAP 	=	108,
	MKT_NII 	=	109,
	MKT_KYO 	=	110,
	MKT_HIR 	=	111,
	MKT_FKA 	=	112,
	MKT_OSA 	=	113,
	MKT_HFE 	=	114,
	MKT_BER 	=	115,
	MKT_HAN 	=	116,
	MKT_STU 	=	117,
	MKT_BRE 	=	118,
	MKT_M119 	=	119,
	MKT_BRN 	=	120,
	MKT_M121 	=	121,
	MKT_M122 	=	122,
	MKT_M123 	=	123,
	MKT_ROM 	=	124,
	MKT_TRN 	=	125,
	MKT_GOA 	=	126,
	MKT_NAP 	=	127,
	MKT_PAL 	=	128,
	MKT_BLO 	=	129,
	MKT_VCE 	=	130,
	MKT_TRI 	=	131,
	MKT_AQC 	=	132,
	MKT_HEL 	=	133,
	MKT_WSE 	=	134,
	MKT_BOR 	=	135,
	MKT_LIL 	=	136,
	MKT_LYO 	=	137,
	MKT_MRS 	=	138,
	MKT_NAY 	=	139,
	MKT_NAN 	=	140,
	MKT_M141 	=	141,
	MKT_LAG 	=	142,
	MKT_ZSE 	=	143,
	MKT_SHH 	=	144,
	MKT_BSE 	=	145,
	MKT_CAL 	=	146,
	MKT_DES 	=	147,
	MKT_MDS 	=	148,
	MKT_JKT 	=	149,
	MKT_KLS 	=	150,
	MKT_KAR 	=	151,
	MKT_MAK 	=	152,
	MKT_MNL 	=	153,
	MKT_FTM 	=	154,
	MKT_SES 	=	155,
	MKT_KSC 	=	156,
	MKT_MAU 	=	157,
	MKT_SET 	=	158,
	MKT_BAH 	=	159,
	MKT_CAI 	=	160,
	MKT_AMM 	=	161,
	MKT_KUW 	=	162,
	MKT_BUE 	=	163,
	MKT_RIO 	=	164,
	MKT_SAO 	=	165,
	MKT_SGO 	=	166,
	MKT_BOG 	=	167,
	MKT_MEX 	=	168,
	MKT_CCS 	=	169,
	MKT_NFE 	=	170,
	MKT_IND 	=	171,
	MKT_FIX 	=	172,
	MKT_LOT 	=	173,
	MKT_MAT 	=	174,
	MKT_TAI 	=	175,
	MKT_IPE 	=	176,
	MKT_M177 	=	177,
	MKT_M178 	=	178,
	MKT_M179 	=	179,
	MKT_SOP 	=	180,
	MKT_REU 	=	181,
	MKT_LIS 	=	182,
	MKT_OPO 	=	183,
	MKT_NOM 	=	184,
	MKT_M185 	=	185,
	MKT_RTS 	=	186,
	MKT_ASX 	=	187,
	MKT_IFX 	=	188,
	MKT_PmI 	=	189,
	MKT_MCE 	=	190,
	MKT_M191 	=	191,
	MKT_TGE 	=	192,
	MKT_TSU 	=	193,
	MKT_KRE 	=	194,
	MKT_MRV 	=	195,
	MKT_AOM 	=	196,
	MKT_BFX 	=	197,
	MKT_BRT 	=	198,
	MKT_DTB 	=	199,
	MKT_MRF 	=	200,
	MKT_M201 	=	201,
	MKT_GER 	=	202,
	MKT_MST 	=	203,
	MKT_IST 	=	204,
	MKT_MUS 	=	205,
	MKT_ABJ 	=	206,
	MKT_NAI 	=	207,
	MKT_TUN 	=	208,
	MKT_FSI 	=	209,
	MKT_NIN 	=	210,
	MKT_MCP 	=	211,
	MKT_OTB 	=	212,
	MKT_SIC 	=	213,
	MKT_RCT 	=	214,
	MKT_IGF 	=	215,
	MKT_MWQ 	=	216,
	MKT_PSQ 	=	217,
	MKT_PHQ 	=	218,
	MKT_JSD 	=	219,
	MKT_ECM 	=	220,
	MKT_OBB 	=	221,
	MKT_IFM 	=	222,
	MKT_MFI 	=	223,
	MKT_SME 	=	224,
	MKT_SHZ 	=	225,
	MKT_RSA 	=	226,
	MKT_BUD 	=	227,
	MKT_PHS 	=	228,
	MKT_MLT 	=	229,
	MKT_M230 	=	230,
	MKT_SZM 	=	231,
	MKT_SZF 	=	232,
	MKT_JBT 	=	233,
	MKT_MDC 	=	234,
	MKT_NTC 	=	235,
	MKT_YSE 	=	236,
	MKT_OTE 	=	237,
	MKT_NAK 	=	238,
	MKT_IOT 	=	239,
	MKT_TOT 	=	240,
	MKT_AHM 	=	241,
	MKT_KLF 	=	242,
	MKT_CSE 	=	243,
	MKT_BEC 	=	244,
	MKT_MXI 	=	245,
	MKT_ZHC 	=	246,
	MKT_BJC 	=	247,
	MKT_WHS 	=	248,
	MKT_GUF 	=	249,
	MKT_BMF 	=	250,
	MKT_VSE 	=	251,
	MKT_SFX 	=	252,
	MKT_M253 	=	253,
	MKT_DLC 	=	254,
	MKT_CSW 	=	255,
} MARKETCODE;

typedef enum {
	FID_REC_TYPE = 1,
	FID_WRT_DSK = 2,
	FID_DTL = 3,
	FID_TIME_ZONE = 4,
	FID_SUSPEN_FG = 5,
	FID_OPEN_FG = 6,
	FID_TEST_FG = 7,
	FID_MKT_CODE = 8,
	FID_SUB_MKT = 9,
	FID_EAS_FG = 10,
	FID_SORT_ID = 11,
	FID_AUTO_FG = 12,
	FID_SHSELL_FG = 13,
	FID_CCASS_FG = 14,
	FID_IDSS_FG = 15,
	FID_SDE_FG = 16,
	FID_LIST_ST = 17,
	FID_BID_FG = 18,
	FID_ASK_FG = 19,
	FID_NOM_TYPE = 20,
	FID_CLS_TYPE = 21,
	FID_DELAY_FG = 22,
	FID_NOMUD_IND = 23,
	FID_CP_FG = 24,
	FID_EFN_FG = 25,
	FID_STYLE = 26,
	FID_YMT_IND = 27,
	FID_BOND_STS = 28,
	FID_SPARE_UC1 = 29,
	FID_SPARE_UC2 = 30,
	FID_REV_UCH1 = 31,
	FID_REV_UCH2 = 32,
	FID_REV_UCH3 = 33,
	FID_REV_UCH4 = 34,
	FID_REV_UCH5 = 35,
	FID_REV_UCH6 = 36,
	FID_REV_UCH7 = 37,
	FID_REV_UCH8 = 38,
	FID_REV_UCH9 = 39,
	FID_REV_UCH10 = 40,
	FID_REV_UCH11 = 41,
	FID_REV_UCH12 = 42,
	FID_XWRT_TYPE = 43,
	FID_REV_UCH14 = 44,
	FID_REV_UCH15 = 45,
	FID_REV_UCH16 = 46,
	FID_REV_UCH17 = 47,
	FID_REV_UCH18 = 48,
	FID_REV_UCH19 = 49,
	FID_REV_UCH20 = 50,
	FID_NOTICE = 51,
	FID_OTHR_HALT = 52,
	FID_INDUSTRY = 53,
	FID_REV_UC1 = 101,
	FID_REV_UC2 = 102,
	FID_REV_UC3 = 103,
	FID_REV_UC4 = 104,
	FID_REV_UC5 = 105,
	FID_REV_UC6 = 106,
	FID_REV_UC7 = 107,
	FID_REV_UC8 = 108,
	FID_REV_UC9 = 109,
	FID_REV_UC10 = 110,
	FID_REV_SH1 = 121,
	FID_REV_SH2 = 122,
	FID_REV_SH3 = 123,
	FID_REV_SH4 = 124,
	FID_REV_SH5 = 125,
	FID_REV_SH6 = 126,
	FID_REV_SH7 = 127,
	FID_REV_SH8 = 128,
	FID_REV_SH9 = 129,
	FID_REV_SH10 = 130,
	FID_CURR_CODE = 151,
	FID_TOTAL_NUM = 152,
	FID_SPDTBL_COD = 153,
	FID_FD = 154,
	FID_CURR_UNIT = 155,
	FID_LOT_SIZE = 156,
	FID_SPARE_US1 = 157,
	FID_SPARE_US2 = 158,
	FID_SPARE_US3 = 159,
	FID_SPARE_US4 = 160,
	FID_REV_US1 = 161,
	FID_REV_US2 = 162,
	FID_REV_US3 = 163,
	FID_REV_US4 = 164,
	FID_REV_US5 = 165,
	FID_REV_US6 = 166,
	FID_REV_US7 = 167,
	FID_REV_US8 = 168,
	FID_REV_US9 = 169,
	FID_REV_US10 = 170,
	FID_REV_LG1 = 201,
	FID_REV_LG2 = 202,
	FID_BID_QTY2 = 203,
	FID_BID_QTY3 = 204,
	FID_BID_QTY4 = 205,
	FID_BID_QTY5 = 206,
	FID_ASK_QTY2 = 207,
	FID_ASK_QTY3 = 208,
	FID_ASK_QTY4 = 209,
	FID_ASK_QTY5 = 210,
	FID_TOTAL = 241,
	FID_OSN = 242,
	FID_OT_PRICE = 243,
	FID_OUT_QTY = 244,
	FID_FILLED_QTY = 245,
	FID_TOTAL_QTY = 246,
	FID_REJ_QTY = 247,
	FID_TRADE_QTY = 248,
	FID_REJ_TIME = 249,
	FID_OT_TIME = 250,
	FID_REJ_TRD = 251,
	FID_BID_QTY = 252,
	FID_ASK_QTY = 253,
	FID_OPEN_INT = 254,
	FID_HASP_ID = 255,
	FID_SPARE_UL2 = 256,
	FID_LINK = 257,
	FID_PLINK = 258,
	FID_NLINK = 259,
	FID_SPARE_UL3 = 260,
	FID_REV_UL1 = 261,
	FID_REV_UL2 = 262,
	FID_REV_UL3 = 263,
	FID_REV_UL4 = 264,
	FID_REV_UL5 = 265,
	FID_REV_UL6 = 266,
	FID_REV_UL7 = 267,
	FID_REV_UL8 = 268,
	FID_REV_UL9 = 269,
	FID_REV_UL10 = 270,
	FID_REV_UL11 = 271,
	FID_REV_UL12 = 272,
	FID_REV_UL13 = 273,
	FID_REV_UL14 = 274,
	FID_REV_UL15 = 275,
	FID_REV_UL16 = 276,
	FID_REV_UL17 = 277,
	FID_REV_UL18 = 278,
	FID_REV_UL19 = 279,
	FID_REV_UL20 = 280,
	FID_INT_PRE = 281,
	FID_1MCHG = 282,
	FID_3MCHG = 283,
	FID_12MTH_PCHG = 284,
	FID_NETCHG = 285,
	FID_PCTCHG = 286,
	FID_PREMIUM = 287,
	FID_SPARE_FT1 = 288,
	FID_SHROFR_PCT = 289,
	FID_SPARE_FT3 = 290,
	FID_REV_FT1 = 291,
	FID_REV_FT2 = 292,
	FID_REV_FT3 = 293,
	FID_REV_FT4 = 294,
	FID_REV_FT5 = 295,
	FID_REV_FT6 = 296,
	FID_REV_FT7 = 297,
	FID_REV_FT8 = 298,
	FID_REV_FT9 = 299,
	FID_REV_FT10 = 300,
	FID_DHG = 301,
	FID_DLW = 302,
	FID_PRE_CLS = 303,
	FID_NOMINAL = 304,
	FID_YHG = 305,
	FID_YLW = 306,
	FID_BID_SPD = 307,
	FID_ASK_SPD = 308,
	FID_BID = 309,
	FID_ASK = 310,
	FID_EIPOP = 311,
	FID_LHG = 312,
	FID_LLW = 313,
	FID_IEP = 314,
	FID_VAR = 315,
	FID_WEIGHT = 316,
	FID_FLUCT = 317,
	FID_SPARE_UF1 = 318,
	FID_RSI14 = 319,
	FID_MA10 = 320,
	FID_MA50 = 321,
	FID_OPEN = 322,
	FID_CASH_DIV = 323,
	FID_PER = 324,
	FID_YIELD = 325,
	FID_BVAL = 326,
	FID_BIR = 327,
	FID_OCE = 328,
	FID_SPARE_UF2 = 329,
	FID_SPARE_UF3 = 330,
	FID_GEN_UF1 = 331,
	FID_GEN_UF2 = 332,
	FID_GEN_UF3 = 333,
	FID_GEN_UF4 = 334,
	FID_EPS = 335,
	FID_EPS_FY1 = 336,
	FID_EPS_FY2 = 337,
	FID_PE_FY1 = 338,
	FID_PE_FY2 = 339,
	FID_PBR = 340,
	FID_SPARE_UF4 = 341,
	FID_SPARE_UF5 = 342,
	FID_GEAR = 343,
	FID_DELTA = 344,
	FID_CONV_RT = 345,
	FID_STR_PRICE = 346,
	FID_GEN_UF5 = 347,
	FID_GEN_UF6 = 348,
	FID_GEN_UF7 = 349,
	FID_GEN_UF8 = 350,
	FID_GEN_UF9 = 351,
	FID_GEN_UF10 = 352,
	FID_INTIND_VOL = 353,
	FID_IV = 354,
	FID_CR = 355,
	FID_FACEVL = 356,
	FID_NAV = 357,
	FID_ACC_INT = 358,
	FID_CURR_YIELD = 359,
	FID_YTM = 360,
	FID_BID2 = 361,
	FID_BID3 = 362,
	FID_BID4 = 363,
	FID_BID5 = 364,
	FID_ASK2 = 365,
	FID_ASK3 = 366,
	FID_ASK4 = 367,
	FID_ASK5 = 368,
	FID_REV_UFT9 = 369,
	FID_REV_UFT10 = 370,
	FID_SHROUT = 371,
	FID_SHRTRD = 372,
	FID_TURN = 373,
	FID_IEV = 374,
	FID_MKT_CAP = 375,
	FID_ACC_VOL1 = 376,
	FID_ACC_TURN1 = 377,
	FID_ACC_VOL2 = 378,
	FID_ACC_TURN2 = 379,
	FID_OS_MKTVOL = 380,
	FID_REV_DB1 = 381,
	FID_REV_DB2 = 382,
	FID_REV_DB3 = 383,
	FID_REV_DB4 = 384,
	FID_REV_DB5 = 385,
	FID_REV_DB6 = 386,
	FID_REV_DB7 = 387,
	FID_REV_DB8 = 388,
	FID_REV_DB9 = 389,
	FID_REV_DB10 = 390,
	FID_EN_NAME = 401,
	FID_CH_NAME = 402,
	FID_ISIN = 403,
	FID_PNAC = 404,
	FID_CONTR_MTH = 405,
	FID_NEWSLINE1 = 406,
	FID_NEWSLINE2 = 407,
	FID_NEWSLINE3 = 408,
	FID_NEWSLINE4 = 409,
	FID_NEWSLINE5 = 410,
	FID_RICNAME = 411,
	FID_EN_MSG = 412,
	FID_CH_MSG = 413,
	FID_PERM_BITMAP = 414,
	FID_SPARE_TXT2 = 415,
	FID_GEN_TXT1 = 416,
	FID_GEN_TXT2 = 417,
	FID_GEN_TXT3 = 418,
	FID_GEN_TXT4 = 419,
	FID_GEN_TXT5 = 420,
	FID_GEN_TXT6 = 421,
	FID_GEN_TXT7 = 422,
	FID_SCH_NAME = 423,
	FID_SCH_MSG = 424,
	FID_XSCALE_LAB = 425,
	FID_WRT_ISR = 426,
	FID_GEN_TXT12 = 427,
	FID_GEN_TXT13 = 428,
	FID_GEN_TXT14 = 429,
	FID_GEN_TXT15 = 430,
	FID_GEN_TXT16 = 431,
	FID_GEN_TXT17 = 432,
	FID_GEN_TXT18 = 433,
	FID_GEN_TXT19 = 434,
	FID_GEN_TXT20 = 435,
	FID_GEN_TXT21 = 436,
	FID_GEN_TXT22 = 437,
	FID_GEN_TXT33 = 438,
	FID_GEN_TXT24 = 439,
	FID_GEN_TXT25 = 440,
	FID_REV_TXT1 = 441,
	FID_REV_TXT2 = 442,
	FID_REV_TXT3 = 443,
	FID_REV_TXT4 = 444,
	FID_REV_TXT5 = 445,
	FID_REV_TXT6 = 446,
	FID_REV_TXT7 = 447,
	FID_REV_TXT8 = 448,
	FID_REV_TXT9 = 449,
	FID_REV_TXT10 = 450,
	FID_TXT_PG = 451,
	FID_TXT_CH_PG = 452,
	FID_SITE_DATA = 453,
	FID_REV_PG1 = 454,
	FID_REV_PG2 = 455,
	FID_REV_PG3 = 456,
	FID_REV_PG4 = 457,
	FID_REV_PG5 = 458,
	FID_REV_PG6 = 459,
	FID_REV_PG7 = 460,
	FID_REV_PG8 = 461,
	FID_REV_PG9 = 462,
	FID_REV_PG10 = 463,
	FID_REV_PG11 = 464,
	FID_REV_PG12 = 465,
	FID_REV_PG13 = 466,
	FID_REV_PG14 = 467,
	FID_REV_PG15 = 468,
	FID_REV_PG16 = 469,
	FID_REV_PG17 = 470,
	FID_TATXT_PG = 471,
	FID_TATXT_CH_PG = 472,
	FID_MA5 = 501,
	FID_MA25 = 502,
	FID_MA75 = 503,
	FID_MA100 = 504,
	FID_MA200 = 505,
	FID_MACD = 506,
	FID_SIGNAL = 507,
	FID_PCT_K = 508,
	FID_PCT_D = 509,
	FID_BLK_SCHOLE = 510,
	FID_OT_DATE = 1099,
	FID_REJ_DATE = 1100,
	FID_LIST_DATE = 1101,
	FID_DELIST_DATE = 1102,
	FID_EIPO_SDATE = 1103,
	FID_EIPO_EDATE = 1104,
	FID_SYS_DATE = 1105,
	FID_TRD_DATE = 1106,
	FID_LHD = 1107,
	FID_LWD = 1108,
	FID_MAT_DT = 1109,
	FID_BMD = 1110,
	FID_BCSD = 1111,
	FID_BCND = 1112,
	FID_EXD = 1113,
	FID_NAVD = 1114,
	FID_PREV_DATE = 1115,
	FID_DIV_DATE = 1116,
	FID_REV_DATE1 = 1117,
	FID_LSTTRD_DATE = 1118,
	FID_REV_DATE3 = 1119,
	FID_REV_DATE4 = 1120,
	FID_SYS_TIME = 1201,
	FID_REV_SEC1 = 1202,
	FID_REV_SEC2 = 1203,
	FID_REV_SEC3 = 1204,
	FID_TRT_MIN = 1211,
	FID_EIPO_ST = 1212,
	FID_EIPO_ET = 1213,
	FID_DELAY = 1214,
	FID_REV_MIN1 = 1215,
	FID_REV_MIN2 = 1216,
	FID_REV_MIN3 = 1217,
	FID_REV_MIN4 = 1218,
	FID_REV_MIN5 = 1219,
	FID_REV_MIN6 = 1220,
	FID_TRAN_LOG = 1301,
	FID_BS_STRENGTH = 1302,
	FID_PRC_VOL = 1303,
	FID_TXN_LOG = 1304,
	FID_MTC_VAL = 1305,
	FID_BS_STRN_15TICK = 1306,
	FID_YL_OSMKTVOL = 1307,
	FID_YL_SPARE2 = 1308,
	FID_YL_SPARE3 = 1309,
	FID_PRC_VOL2 = 1310,
	FID_EN_LBLST = 1351,
	FID_CH_LBLST = 1352,
	FID_FDLST = 1353,
	FID_TYPE_LST = 1354,
	FID_FDLINK = 1355,
	FID_REV_LST1 = 1356,
	FID_REV_LST2 = 1357,
	FID_REV_LST3 = 1358,
	FID_REV_LST4 = 1359,
	FID_REV_LST5 = 1360,
	FID_BBL = 1361,
	FID_ABL = 1362,
	FID_BID_ORD1 = 1371,
	FID_BID_ORD2 = 1372,
	FID_BID_ORD3 = 1373,
	FID_BID_ORD4 = 1374,
	FID_BID_ORD5 = 1375,
	FID_ASK_ORD1 = 1376,
	FID_ASK_ORD2 = 1377,
	FID_ASK_ORD3 = 1378,
	FID_ASK_ORD4 = 1379,
	FID_ASK_ORD5 = 1380,
	FID_SLINK = 1381,
	FID_BLINK = 1382,
	FID_ILINK = 1383,
	FID_ULINK = 1384,
	FID_CLINK = 1385,
	FID_SPARE_LINK1 = 1386,
	FID_SPARE_LINK2 = 1387,
	FID_SPARE_LINK3 = 1388,
	FID_SPARE_LINK4 = 1389,
	FID_SPARE_LINK5 = 1390,
	FID_HEADLINE_LINK = 1391,
	FID_HEADLINE = 1392,
	FID_YHEADLINE = 1393,
	FID_WLINK = 1401,
	FID_TLSG_LIST = 1402,
	FID_MTC_HML = 1403,
	FID_MTC_PTS = 1404,
	FID_TM_RANGE = 1405,
	FID_MTH_HML = 1406,
	FID_MTH_DATA = 1407,
	FID_TM_LAB = 1408,
	FID_DT_LAB = 1409,
	FID_HIS_DATA = 1410,
	FID_IBLE = 1411,
	FID_IBLU = 1412,
	FID_CHT_DATA = 1413,
	FID_SPR_DATA = 1450,
	FID_QL_LIST = 1460,
	FID_QL_01 = 1461,
	FID_QL_02 = 1462,
	FID_QL_03 = 1463,
	FID_QL_04 = 1464,
	FID_QL_05 = 1465,
	FID_QL_06 = 1466,
	FID_QL_07 = 1467,
	FID_QL_08 = 1468,
	FID_QL_09 = 1469,
	FID_QL_10 = 1470,
	FID_QL_11 = 1471,
	FID_QL_12 = 1472,
	FID_QL_13 = 1473,
	FID_QL_14 = 1474,
	FID_QL_15 = 1475,
	FID_QL_16 = 1476,
	FID_QL_17 = 1477,
	FID_QL_18 = 1478,
	FID_QL_19 = 1479,
	FID_QL_20 = 1480,
	FID_MTC_01 = 1500,
	FID_MTC_02 = 1501,
	FID_MTC_03 = 1502,
	FID_MTC_04 = 1503,
	FID_MTC_05 = 1504,
	FID_MTCV_01 = 1520,
	FID_MTCV_02 = 1521,
	FID_MTCV_03 = 1522,
	FID_MTCV_04 = 1523,
	FID_MTCV_05 = 1524,
	FID_MTCF_01 = 1525,
	FID_MTCF_02 = 1526,
	FID_MTCF_03 = 1527,
	FID_MTCF_04 = 1528,
	FID_MTCF_05 = 1529,
	FID_OBBL = 1541,
	FID_OABL = 1542,
	FID_MOBBL = 1543,
	FID_MOABL = 1544,
	FID_VOBBL = 1545,
	FID_VOABL = 1546,
	FID_MVOBBL = 1547,
	FID_MVOABL = 1548,
	FID_KTRADE = 1600,
	FID_KPRICE = 1601,
	FID_KSTRIKE = 1602,
	FID_KCALLS_BID = 1603,
	FID_KCALLS_BID_QTY = 1604,
	FID_KCALLS_ASK = 1605,
	FID_KCALLS_ASK_QTY = 1606,
	FID_KCALLS_LAST = 1607,
	FID_KCALLS_LAST_VOL = 1608,
	FID_KCALLS_HIGH = 1609,
	FID_KCALLS_LOW = 1610,
	FID_KCALLS_CUMULATIVE_VOL = 1611,
	FID_KPUTS_BID = 1612,
	FID_KPUTS_BID_QTY = 1613,
	FID_KPUTS_ASK = 1614,
	FID_KPUTS_ASK_QTY = 1615,
	FID_KPUTS_LAST = 1616,
	FID_KPUTS_LAST_VOL = 1617,
	FID_KPUTS_HIGH = 1618,
	FID_KPUTS_LOW = 1619,
	FID_KPUTS_CUMULATIVE_VOL = 1620,
	FID_KOPEN_INTEREST = 1621,
	FID_KHIGH = 1622,
	FID_KLOW = 1623,
	FID_KEAS = 1624,
	FID_KLAST = 1625,
	FID_KLAST_QTY = 1626,
	FID_KCUMULATIVE_VOL = 1627,
	FID_KPRVEOUS = 1628,
	FID_KOPEN = 1629,
	FID_10KBID = 1700,
	FID_10KASK = 1701,
	FID_10KHIGH = 1702,
	FID_10KLOW = 1703,
	FID_MTC_DTS = 1800,
	FID_MTC_DTS1 = 1801,
	FID_MTC_DTS2 = 1802,
	FID_MTC_DTS3 = 1803,
	FID_MTC_DTS4 = 1804,
	FID_MTC_DTS5 = 1805,
	FID_MTC_DTS6 = 1806,
	FID_MTC_DTS7 = 1807,
	FID_MTC_DTS8 = 1808,
	FID_MTC_DTS9 = 1809,
	FID_SLINK1 = 1810,
	FID_SLINK2 = 1811,
	FID_SLINK3 = 1812,
	FID_SLINK4 = 1813,
	FID_SLINK5 = 1814,
	FID_SLINK6 = 1815,
	FID_SLINK7 = 1816,
	FID_SLINK8 = 1817,
	FID_SLINK9 = 1818,
	FID_SLINK10 = 1819,
	FID_PRCVOLWSEQ1 = 1830,
	FID_PRCVOLWSEQ2 = 1831,
	FID_PRCVOLWSEQ3 = 1832,
	FID_IDN_DELTA = 1840,
	FID_REV_UFT11 = 1841,
	FID_REV_UFT12 = 1842,
	FID_REV_UFT13 = 1843,
	FID_REV_UFT14 = 1844,
	FID_REV_UFT15 = 1845,
	FID_REV_UFT16 = 1846,
	FID_REV_UFT17 = 1847,
	FID_REV_UFT18 = 1848,
	FID_REV_UFT19 = 1849,
	FID_REV_UFT20 = 1850,
	FID_REV_UFT21 = 1851,
	FID_REV_UFT22 = 1852,
	FID_REV_UFT23 = 1853,
	FID_REV_UFT24 = 1854,
	FID_REV_UFT25 = 1855,
	FID_REV_UFT26 = 1856,
	FID_REV_UFT27 = 1857,
	FID_REV_UFT28 = 1858,
	FID_REV_UFT29 = 1859,
	FID_REV_UFT30 = 1860,
	FID_REV_UFT31 = 1861,
	FID_REV_UFT32 = 1862,
	FID_REV_UFT33 = 1863,
	FID_REV_UFT34 = 1864,
	FID_REV_UFT35 = 1865,
	FID_REV_UFT36 = 1866,
	FID_CUR_EMA10 = 1867,
	FID_CUR_EMA50 = 1868,
	FID_CUR_RSI14 = 1869,
	FID_FKS_K = 1870,
	FID_FKS_D = 1871,
	FID_FKS_PREVK = 1872,
	FID_FKS_PREVD = 1873,
	FID_SKS_K = 1874,
	FID_SKS_D = 1875,
	FID_SKS_PREVK = 1876,
	FID_SKS_PREVD = 1877,
	FID_MACD_DATA = 1878,
	FID_MACD_SIG = 1879,
	FID_MACD_DIFF = 1880,
	FID_MACD_PREVDATA = 1881,
	FID_MACD_PREVSIG = 1882,
	FID_WMA10 = 1883,
	FID_WMA50 = 1884,
	FID_EMA10 = 1885,
	FID_EMA50 = 1886,
	FID_CUR_MA10 = 1887,
	FID_CUR_MA50 = 1888,
	FID_CUR_WMA10 = 1889,
	FID_REV_PRCVOL1 = 1890,
	FID_REV_PRCVOL2 = 1891,
	FID_REV_PRCVOL3 = 1892,
	FID_REV_PRCVOL4 = 1893,
	FID_REV_PRCVOL5 = 1894,
	FID_REV_PRCVOL6 = 1895,
	FID_REV_PRCVOL7 = 1896,
	FID_REV_PRCVOL8 = 1897,
	FID_REV_PRCVOL9 = 1898,
	FID_REV_PRCVOL10 = 1899,
	FID_REV_PRCVOL11 = 1900,
	FID_REV_PRCVOL12 = 1901,
	FID_REV_PRCVOL13 = 1902,
	FID_REV_PRCVOL14 = 1903,
	FID_REV_PRCVOL15 = 1904,
	FID_REV_PRCVOL16 = 1905,
	FID_REV_PRCVOL17 = 1906,
	FID_REV_PRCVOL18 = 1907,
	FID_REV_PRCVOL19 = 1908,
	FID_REV_PRCVOL20 = 1909,
	FID_REV_DTCLB1 = 1910,
	FID_REV_DTCLB2 = 1911,
	FID_REV_DTCLB3 = 1912,
	FID_REV_DTCLB4 = 1913,
	FID_REV_DTCLB5 = 1914,
	FID_REV_DTCLB6 = 1915,
	FID_REV_DTCLB7 = 1916,
	FID_REV_DTCLB8 = 1917,
	FID_REV_DTCLB9 = 1918,
	FID_REV_DTCLB10 = 1919,
	FID_REV_DTCLB11 = 1920,
	FID_REV_DTCLB12 = 1921,
	FID_REV_DTCLB13 = 1922,
	FID_REV_DTCLB14 = 1923,
	FID_REV_DTCLB15 = 1924,
	FID_REV_DTCLB16 = 1925,
	FID_REV_DTCLB17 = 1926,
	FID_REV_DTCLB18 = 1927,
	FID_REV_DTCLB19 = 1928,
	FID_REV_DTCLB20 = 1929,
	FID_COUPON_TYPE = 1930,
	FID_RATINGS = 1931,
	FID_GEN_TXT26 = 1932,
	FID_GEN_TXT27 = 1933,
	FID_GEN_TXT28 = 1934,
	FID_GEN_TXT29 = 1935,
	FID_GEN_TXT30 = 1936,
	FID_GEN_TXT31 = 1937,
	FID_GEN_TXT32 = 1938,
	FID_GEN_TXT33A = 1939,
	FID_GEN_TXT34 = 1940,
	FID_GEN_TXT35 = 1941,
	FID_GEN_TXT36 = 1942,
	FID_GEN_TXT37 = 1943,
	FID_GEN_TXT38 = 1944,
	FID_GEN_TXT39 = 1945,
	FID_GEN_TXT40 = 1946,
	FID_GEN_TXT41 = 1947,
	FID_GEN_TXT42 = 1948,
	FID_GEN_TXT43 = 1949,
	FID_VOL_RATIO = 1950,
	FID_REV_DB11 = 1951,
	FID_REV_DB12 = 1952,
	FID_REV_DB13 = 1953,
	FID_REV_DB14 = 1954,
	FID_REV_DB15 = 1955,
	FID_REV_DB16 = 1956,
	FID_REV_DB17 = 1957,
	FID_REV_DB18 = 1958,
	FID_REV_DB19 = 1959,

	FID_DEAL = 1960,
	FID_REV_UL21 = 1961,
	FID_REV_UL22 = 1962,
	FID_REV_UL23 = 1963,
	FID_REV_UL24 = 1964,
	FID_REV_UL25 = 1965,
	FID_REV_UL26 = 1966,
	FID_REV_UL27 = 1967,
	FID_REV_UL28 = 1968,
	FID_REV_UL29 = 1969,
	FID_REV_UL30 = 1970,
	FID_REV_UL31 = 1971,
	FID_REV_UL32 = 1972,
	FID_REV_UL33 = 1973,
	FID_REV_UL34 = 1974,
	FID_REV_UL35 = 1975,
	FID_REV_UL36 = 1976,
	FID_REV_UL37 = 1977,
	FID_REV_UL38 = 1978,
	FID_REV_UL39 = 1979,
	FID_REV_UL40 = 1980,
	FID_REV_UL41 = 1981,
	FID_REV_UL42 = 1982,
	FID_REV_UL43 = 1983,
	FID_REV_UL44 = 1984,
	FID_REV_UL45 = 1985,
	FID_REV_UL46 = 1986,
	FID_REV_UL47 = 1987,
	FID_REV_UL48 = 1988,
	FID_REV_UL49 = 1989,
	FID_REV_UL50 = 1990,
	FID_REV_UL51 = 1991,
	FID_REV_UL52 = 1992,
	FID_REV_UL53 = 1993,
	FID_COP_QTY = 1994,
	FID_REV_UL55 = 1995,
	FID_REV_UL56 = 1996,
	FID_REV_UL57 = 1997,
	FID_REV_UL58 = 1998,
	FID_REV_UL59 = 1999,

	FID_DAYS_DELIVER = 2000,
	FID_REV_US11 = 2001,
	FID_REV_US12 = 2002,
	FID_REV_US13 = 2003,
	FID_REV_US14 = 2004,
	FID_REV_US15 = 2005,
	FID_REV_US16 = 2006,
	FID_REV_US17 = 2007,
	FID_REV_US18 = 2008,
	FID_REV_US19 = 2009,
	FID_REV_US20 = 2010,
	FID_REV_US21 = 2011,
	FID_REV_US22 = 2012,
	FID_REV_US23 = 2013,
	FID_REV_US24 = 2014,
	FID_REV_US25 = 2015,
	FID_REV_US26 = 2016,
	FID_REV_US27 = 2017,
	FID_REV_US28 = 2018,
	FID_REV_US29 = 2019,
	FID_REV_US30 = 2020,
	FID_REV_US31 = 2021,
	FID_REV_US32 = 2022,
	FID_REV_US33 = 2023,
	FID_REV_US34 = 2024,
	FID_REV_US35 = 2025,
	FID_REV_US36 = 2026,
	FID_REV_US37 = 2027,
	FID_REV_US38 = 2028,
	FID_REV_US39 = 2029,
	FID_REV_US40 = 2030,
	FID_REV_US41 = 2031,
	FID_REV_US42 = 2032,
	FID_REV_US43 = 2033,
	FID_REV_US44 = 2034,
	FID_REV_US45 = 2035,
	FID_REV_US46 = 2036,
	FID_REV_US47 = 2037,
	FID_REV_US48 = 2038,
	FID_REV_US49 = 2039,
	FID_REV_US50 = 2040,
	FID_REV_US51 = 2041,
	FID_REV_US52 = 2042,
	FID_REV_US53 = 2043,
	FID_REV_US54 = 2044,
	FID_REV_US55 = 2045,
	FID_REV_US56 = 2046,
	FID_REV_US57 = 2047,
	FID_REV_US58 = 2048,
	FID_REV_US59 = 2049,

	FID_SETTLE_DATE = 2050,
	FID_OI_DATE = 2051,
	FID_REV_DATE5 = 2052,
	FID_REV_DATE6 = 2053,
	FID_REV_DATE7 = 2054,
	FID_REV_DATE8 = 2055,
	FID_REV_DATE9 = 2056,
	FID_REV_DATE10 = 2057,
	FID_REV_DATE11 = 2058,
	FID_REV_DATE12 = 2059,
	FID_REV_DATE13 = 2060,
	FID_REV_DATE14 = 2061,
	FID_REV_DATE15 = 2062,
	FID_REV_DATE16 = 2063,
	FID_REV_DATE17 = 2064,
	FID_REV_DATE18 = 2065,
	FID_REV_DATE19 = 2066,
	FID_REV_DATE20 = 2067,
	FID_REV_DATE21 = 2068,
	FID_REV_DATE22 = 2069,
	FID_REV_DATE23 = 2070,
	FID_REV_DATE24 = 2071,
	FID_REV_DATE25 = 2072,
	FID_REV_DATE26 = 2073,
	FID_REV_DATE27 = 2074,
	FID_REV_DATE28 = 2075,
	FID_REV_DATE29 = 2076,
	FID_REV_DATE30 = 2077,
	FID_REV_DATE31 = 2078,
	FID_REV_DATE32 = 2079,
	FID_REV_DATE33 = 2080,
	FID_REV_DATE34 = 2081,
	FID_REV_DATE35 = 2082,
	FID_REV_DATE36 = 2083,
	FID_REV_DATE37 = 2084,
	FID_REV_DATE38 = 2085,
	FID_REV_DATE39 = 2086,
	FID_REV_DATE40 = 2087,
	FID_REV_DATE41 = 2088,
	FID_REV_DATE42 = 2089,
	FID_REV_DATE43 = 2090,
	FID_REV_DATE44 = 2091,
	FID_REV_DATE45 = 2092,
	FID_REV_DATE46 = 2093,
	FID_REV_DATE47 = 2094,
	FID_REV_DATE48 = 2095,
	FID_REV_DATE49 = 2096,
	FID_REV_DATE50 = 2097,
	FID_REV_DATE51 = 2098,
	FID_REV_DATE52 = 2099,

	FID_TRAN_LOG1 = 2100,
	FID_TRAN_LOG2 = 2101,
	FID_TRAN_LOG3 = 2102,
	FID_TRAN_LOG4 = 2103,
	FID_TRAN_LOG5 = 2104,
	FID_TRAN_LOG6 = 2105,
	FID_TRAN_LOG7 = 2106,
	FID_TRAN_LOG8 = 2107,
	FID_TRAN_LOG9 = 2108,
	FID_TRAN_LOG10 = 2109,

	FID_REV_UCH21 = 2110,
	FID_REV_UCH22 = 2111,
	FID_REV_UCH23 = 2112,
	FID_REV_UCH24 = 2113,
	FID_REV_UCH25 = 2114,
	FID_REV_UCH26 = 2115,
	FID_REV_UCH27 = 2116,
	FID_REV_UCH28 = 2117,
	FID_REV_UCH29 = 2118,
	FID_REV_UCH30 = 2119,
	FID_REV_UCH31 = 2120,
	FID_REV_UCH32 = 2121,
	FID_REV_UCH33 = 2122,
	FID_REV_UCH34 = 2123,
	FID_REV_UCH35 = 2124,
	FID_REV_UCH36 = 2125,
	FID_REV_UCH37 = 2126,
	FID_REV_UCH38 = 2127,
	FID_REV_UCH39 = 2128,
	FID_REV_UCH40 = 2129,
	FID_REV_UCH41 = 2130,
	FID_REV_UCH42 = 2131,
	FID_REV_UCH43 = 2132,
	FID_REV_UCH44 = 2133,
	FID_REV_UCH45 = 2134,
	FID_REV_UCH46 = 2135,
	FID_REV_UCH47 = 2136,
	FID_REV_UCH48 = 2137,
	FID_REV_UCH49 = 2138,
	FID_REV_UCH50 = 2139,
	FID_REV_UCH51 = 2140,
	FID_REV_UCH52 = 2141,
	FID_REV_UCH53 = 2142,
	FID_REV_UCH54 = 2143,
	FID_REV_UCH55 = 2144,
	FID_REV_UCH56 = 2145,
	FID_REV_UCH57 = 2146,
	FID_REV_UCH58 = 2147,
	FID_COP_TYPE = 2148,
	FID_REV_UCH60 = 2149,
	FID_REV_UCH61 = 2150,
	FID_REV_UCH62 = 2151,
	FID_REV_UCH63 = 2152,
	FID_REV_UCH64 = 2153,
	FID_REV_UCH65 = 2154,
	FID_REV_UCH66 = 2155,
	FID_REV_UCH67 = 2156,
	FID_REV_UCH68 = 2157,
	FID_REV_UCH69 = 2158,
	FID_REV_UCH70 = 2159,
	FID_YL_SPARE4 = 2160,
	FID_YL_SPARE5 = 2161,
	FID_YL_SPARE6 = 2162,
	FID_YL_SPARE7 = 2163,
	FID_YL_SPARE8 = 2164,
	FID_YL_SPARE9 = 2165,
	FID_YL_SPARE10 = 2166,
	FID_YL_SPARE11 = 2167,
	FID_YL_SPARE12 = 2168,
	FID_YL_SPARE13 = 2169,
	FID_YL_SPARE14 = 2170,
	FID_YL_SPARE15 = 2171,
	FID_YL_SPARE16 = 2172,
	FID_YL_SPARE17 = 2173,
	FID_YL_SPARE18 = 2174,
	FID_YL_SPARE19 = 2175,
	FID_YL_SPARE20 = 2176,
	FID_YL_SPARE21 = 2177,
	FID_YL_SPARE22 = 2178,
	FID_YL_SPARE23 = 2179,

	FID_CHT_SPARE1 = 2180,
	FID_CHT_SPARE2 = 2181,
	FID_CHT_SPARE3 = 2182,
	FID_CHT_SPARE4 = 2183,
	FID_CHT_SPARE5 = 2184,
	FID_CHT_SPARE6 = 2185,
	FID_CHT_SPARE7 = 2186,
	FID_CHT_SPARE8 = 2187,
	FID_CHT_SPARE9 = 2188,
	FID_CHT_SPARE10 = 2189,
	FID_CHT_SPARE11 = 2190,
	FID_CHT_SPARE12 = 2191,
	FID_CHT_SPARE13 = 2192,
	FID_CHT_SPARE14 = 2193,
	FID_CHT_SPARE15 = 2194,
	FID_CHT_SPARE16 = 2195,
	FID_CHT_SPARE17 = 2196,
	FID_CHT_SPARE18 = 2197,
	FID_CHT_SPARE19 = 2198,
	FID_CHT_SPARE20 = 2199,

	FID_MTC_06 = 2200,
	FID_MTC_07 = 2201,
	FID_MTC_08 = 2202,
	FID_MTC_09 = 2203,
	FID_MTC_10 = 2204,
	FID_MTC_11 = 2205,
	FID_MTC_12 = 2206,
	FID_MTC_13 = 2207,
	FID_MTC_14 = 2208,
	FID_MTC_15 = 2209,
	FID_MTC_16 = 2210,
	FID_MTC_17 = 2211,
	FID_MTC_18 = 2212,
	FID_MTC_19 = 2213,
	FID_MTC_20 = 2214,
	FID_MTC_21 = 2215,
	FID_MTC_22 = 2216,
	FID_MTC_23 = 2217,
	FID_MTC_24 = 2218,
	FID_MTC_25 = 2219,

	FID_REV_MTCPTS1 = 2220,
	FID_REV_MTCPTS2 = 2221,
	FID_REV_MTCPTS3 = 2222,
	FID_REV_MTCPTS4 = 2223,
	FID_REV_MTCPTS5 = 2224,
	FID_REV_MTCPTS6 = 2225,
	FID_REV_MTCPTS7 = 2226,
	FID_REV_MTCPTS8 = 2227,
	FID_REV_MTCPTS9 = 2228,
	FID_REV_MTCPTS10 = 2229,
	FID_REV_MTCPTS11 = 2230,
	FID_REV_MTCPTS12 = 2231,
	FID_REV_MTCPTS13 = 2232,
	FID_REV_MTCPTS14 = 2233,
	FID_REV_MTCPTS15 = 2234,
	FID_REV_MTCPTS16 = 2235,
	FID_REV_MTCPTS17 = 2236,
	FID_REV_MTCPTS18 = 2237,
	FID_REV_MTCPTS19 = 2238,
	FID_REV_MTCPTS20 = 2239,

	FID_REV_PG18 = 2240,
	FID_REV_PG19 = 2241,
	FID_REV_PG20 = 2242,
	FID_REV_PG21 = 2243,
	FID_REV_PG22 = 2244,
	FID_REV_PG23 = 2245,
	FID_REV_PG24 = 2246,
	FID_REV_PG25 = 2247,
	FID_REV_PG26 = 2248,
	FID_REV_PG27 = 2249,
	FID_REV_PG28 = 2250,
	FID_REV_PG29 = 2251,
	FID_REV_PG30 = 2252,
	FID_REV_PG31 = 2253,
	FID_REV_PG32 = 2254,
	FID_REV_PG33 = 2255,
	FID_REV_PG34 = 2256,
	FID_REV_PG35 = 2257,
	FID_REV_PG36 = 2258,
	FID_REV_PG37 = 2259,
	FID_REV_DB20 = 2260,
	FID_REV_DB21 = 2261,
	FID_REV_DB22 = 2262,
	FID_REV_DB23 = 2263,
	FID_REV_DB24 = 2264,
	FID_REV_DB25 = 2265,
	FID_REV_DB26 = 2266,
	FID_REV_DB27 = 2267,
	FID_REV_DB28 = 2268,
	FID_REV_DB29 = 2269,
	FID_REV_DB30 = 2270,
	FID_REV_DB31 = 2271,
	FID_REV_DB32 = 2272,
	FID_REV_DB33 = 2273,
	FID_REV_DB34 = 2274,
	FID_REV_DB35 = 2275,
	FID_REV_DB36 = 2276,
	FID_REV_DB37 = 2277,
	FID_REV_DB38 = 2278,
	FID_REV_DB39 = 2279,
	FID_REV_DB40 = 2280,
	FID_REV_DB41 = 2281,
	FID_REV_DB42 = 2282,
	FID_REV_DB43 = 2283,
	FID_REV_DB44 = 2284,
	FID_REV_DB45 = 2285,
	FID_REV_DB46 = 2286,
	FID_REV_DB47 = 2287,
	FID_REV_DB48 = 2288,
	FID_REV_DB49 = 2289,
	FID_REV_DB50 = 2290,
	FID_REV_DB51 = 2291,
	FID_REV_DB52 = 2292,
	FID_REV_DB53 = 2293,
	FID_REV_DB54 = 2294,
	FID_REV_DB55 = 2295,
	FID_REV_DB56 = 2296,
	FID_REV_DB57 = 2297,
	FID_REV_DB58 = 2298,
	FID_REV_DB59 = 2299,
	// Lawrence 061120 <<
	FID_CUR_WMA50 = 2300,
	FID_REV_UFT137 = 2301,
	FID_REV_UFT138 = 2302,
	FID_REV_UFT139 = 2303,
	FID_REV_UFT140 = 2304,
	FID_REV_UFT141 = 2305,
	FID_REV_UFT142 = 2306,
	FID_REV_UFT143 = 2307,
	FID_REV_UFT144 = 2308,
	FID_REV_UFT145 = 2309,

	FID_REV_UFT146 = 2310,
	FID_REV_UFT147 = 2311,
	FID_REV_UFT148 = 2312,
	FID_REV_UFT149 = 2313,
	FID_REV_UFT150 = 2314,
	FID_REV_UFT151 = 2315,
	FID_REV_UFT152 = 2316,
	FID_REV_UFT153 = 2317,
	FID_REV_UFT154 = 2318,
	FID_REV_UFT155 = 2319,

	FID_REV_UFT156 = 2320,
	FID_REV_UFT157 = 2321,
	FID_REV_UFT158 = 2322,
	FID_5TH_DY_PC = 2323,
	FID_10TH_DY_PC = 2324,
	FID_20TH_DY_PC = 2325,
	FID_5TH_DY_PMP = 2326,
	FID_10TH_DY_PMP = 2327,
	FID_20TH_DY_PMP = 2328,
	FID_REV_UFT165 = 2329,

	FID_REV_UFT166 = 2330,
	FID_REV_UFT167 = 2331,
	FID_REV_UFT168 = 2332,
	FID_REV_UFT169 = 2333,
	FID_REV_UFT170 = 2334,
	FID_REV_UFT171 = 2335,
	FID_REV_UFT172 = 2336,
	FID_REV_UFT173 = 2337,
	FID_REV_UFT174 = 2338,
	FID_REV_UFT175 = 2339,

	FID_REV_UFT176 = 2340,
	FID_REV_UFT177 = 2341,
	FID_REV_UFT178 = 2342,
	FID_REV_UFT179 = 2343,
	FID_REV_UFT180 = 2344,
	FID_REV_UFT181 = 2345,
	FID_REV_UFT182 = 2346,
	FID_REV_UFT183 = 2347,
	FID_REV_UFT184 = 2348,
	FID_REV_UFT185 = 2349,

	FID_REV_UFT186 = 2350,
	FID_REV_UFT187 = 2351,
	FID_REV_UFT188 = 2352,
	FID_REV_UFT189 = 2353,
	FID_REV_UFT190 = 2354,
	FID_REV_UFT191 = 2355,
	FID_REV_UFT192 = 2356,
	FID_REV_UFT193 = 2357,
	FID_REV_UFT194 = 2358,
	FID_REV_UFT195 = 2359,

	FID_REV_UFT196 = 2360,
	FID_REV_UFT197 = 2361,
	FID_REV_UFT198 = 2362,
	FID_REV_UFT199 = 2363,
	FID_REV_UFT1100 = 2364,
	FID_REV_UFT1101 = 2365,
	FID_REV_UFT1102 = 2366,
	FID_REV_UFT1103 = 2367,
	FID_REV_UFT1104 = 2368,
	FID_REV_UFT1105 = 2369,

	FID_REV_UFT1106 = 2370,
	FID_REV_UFT1107 = 2371,
	FID_REV_UFT1108 = 2372,
	FID_REV_UFT1109 = 2373,
	FID_REV_UFT1110 = 2374,
	FID_REV_UFT1111 = 2375,
	FID_REV_UFT1112 = 2376,
	FID_REV_UFT1113 = 2377,
	FID_REV_UFT1114 = 2378,
	FID_REV_UFT1115 = 2379,

	FID_REV_UFT1116 = 2380,
	FID_REV_UFT1117 = 2381,
	FID_REV_UFT1118 = 2382,
	FID_REV_UFT1119 = 2383,
	FID_REV_UFT1120 = 2384,
	FID_REV_UFT1121 = 2385,
	FID_REV_UFT1122 = 2386,
	FID_REV_UFT1123 = 2387,
	FID_REV_UFT1124 = 2388,
	FID_REV_UFT1125 = 2389,

	FID_REV_UFT1126 = 2390,
	FID_REV_UFT1127 = 2391,
	FID_REV_UFT1128 = 2392,
	FID_REV_UFT1129 = 2393,
	FID_REV_UFT1130 = 2394,
	FID_REV_UFT1131 = 2395,
	FID_REV_UFT1132 = 2396,
	FID_REV_UFT1133 = 2397,
	FID_REV_UFT1134 = 2398,
	FID_COP = 2399,

	FID_MTCV_06 = 2400,
	FID_MTCV_07 = 2401,
	FID_MTCV_08 = 2402,
	FID_MTCV_09 = 2403,
	FID_MTCV_10 = 2404,
	FID_MTCV_11 = 2405,
	FID_MTCV_12 = 2406,
	FID_MTCV_13 = 2407,
	FID_MTCV_14 = 2408,
	FID_MTCV_15 = 2409,
	// Lawrence 061120 >.

	FID_REV_UFT2500 = 2500,
	FID_REV_UFT2501 = 2501,
	FID_REV_UFT2502 = 2502,
	FID_REV_UFT2503 = 2503,
	FID_REV_UFT2504 = 2504,
	FID_REV_UFT2505 = 2505,
	FID_REV_UFT2506 = 2506,
	FID_REV_UFT2507 = 2507,
	FID_REV_UFT2508 = 2508,
	FID_REV_UFT2509 = 2509,
	FID_REV_UFT2510 = 2510,
	FID_REV_UFT2511 = 2511,
	FID_REV_UFT2512 = 2512,
	FID_REV_UFT2513 = 2513,
	FID_REV_UFT2514 = 2514,
	FID_REV_UFT2515 = 2515,
	FID_REV_UFT2516 = 2516,
	FID_REV_UFT2517 = 2517,
	FID_REV_UFT2518 = 2518,
	FID_REV_UFT2519 = 2519,
	FID_REV_UFT2520 = 2520,
	FID_REV_UFT2521 = 2521,
	FID_REV_UFT2522 = 2522,
	FID_REV_UFT2523 = 2523,
	FID_REV_UFT2524 = 2524,
	FID_REV_UFT2525 = 2525,
	FID_REV_UFT2526 = 2526,
	FID_REV_UFT2527 = 2527,
	FID_REV_UFT2528 = 2528,
	FID_REV_UFT2529 = 2529,
	FID_REV_UFT2530 = 2530,
	FID_REV_UFT2531 = 2531,
	FID_REV_UFT2532 = 2532,
	FID_REV_UFT2533 = 2533,
	FID_REV_UFT2534 = 2534,
	FID_REV_UFT2535 = 2535,
	FID_REV_UFT2536 = 2536,
	FID_REV_UFT2537 = 2537,
	FID_REV_UFT2538 = 2538,
	FID_REV_UFT2539 = 2539,
	FID_REV_UFT2540 = 2540,
	FID_REV_UFT2541 = 2541,
	FID_REV_UFT2542 = 2542,
	FID_REV_UFT2543 = 2543,
	FID_REV_UFT2544 = 2544,
	FID_REV_UFT2545 = 2545,
	FID_REV_UFT2546 = 2546,
	FID_REV_UFT2547 = 2547,
	FID_REV_UFT2548 = 2548,
	FID_REV_UFT2549 = 2549,
	FID_REV_UFT2550 = 2550,
	FID_REV_UFT2551 = 2551,
	FID_REV_UFT2552 = 2552,
	FID_REV_UFT2553 = 2553,
	FID_REV_UFT2554 = 2554,
	FID_REV_UFT2555 = 2555,
	FID_REV_UFT2556 = 2556,
	FID_REV_UFT2557 = 2557,
	FID_REV_UFT2558 = 2558,
	FID_REV_UFT2559 = 2559,
	FID_REV_UFT2560 = 2560,
	FID_REV_UFT2561 = 2561,
	FID_REV_UFT2562 = 2562,
	FID_REV_UFT2563 = 2563,
	FID_REV_UFT2564 = 2564,
	FID_REV_UFT2565 = 2565,
	FID_REV_UFT2566 = 2566,
	FID_REV_UFT2567 = 2567,
	FID_REV_UFT2568 = 2568,
	FID_REV_UFT2569 = 2569,
	FID_REV_UFT2570 = 2570,
	FID_REV_UFT2571 = 2571,
	FID_REV_UFT2572 = 2572,
	FID_REV_UFT2573 = 2573,
	FID_REV_UFT2574 = 2574,
	FID_REV_UFT2575 = 2575,
	FID_REV_UFT2576 = 2576,
	FID_REV_UFT2577 = 2577,
	FID_REV_UFT2578 = 2578,
	FID_REV_UFT2579 = 2579,
	FID_REV_UFT2580 = 2580,
	FID_REV_UFT2581 = 2581,
	FID_REV_UFT2582 = 2582,
	FID_REV_UFT2583 = 2583,
	FID_REV_UFT2584 = 2584,
	FID_REV_UFT2585 = 2585,
	FID_REV_UFT2586 = 2586,
	FID_REV_UFT2587 = 2587,
	FID_REV_UFT2588 = 2588,
	FID_REV_UFT2589 = 2589,
	FID_REV_UFT2590 = 2590,
	FID_REV_UFT2591 = 2591,
	FID_REV_UFT2592 = 2592,
	FID_REV_UFT2593 = 2593,
	FID_REV_UFT2594 = 2594,
	FID_REV_UFT2595 = 2595,
	FID_REV_UFT2596 = 2596,
	FID_REV_UFT2597 = 2597,
	FID_REV_UFT2598 = 2598,
	FID_REV_UFT2599 = 2599,
	//added on 25Aug2011
	FID_BID_ORD6 = 2610,
	FID_BID_ORD7 = 2611,
	FID_BID_ORD8 = 2612,
	FID_BID_ORD9 = 2613,
	FID_BID_ORD10 = 2614,

	FID_ASK_ORD6 = 2615,
	FID_ASK_ORD7 = 2616,
	FID_ASK_ORD8 = 2617,
	FID_ASK_ORD9 = 2618,
	FID_ASK_ORD10 = 2619,

	FID_BID_EXACT_QTY6 = 2620,
	FID_BID_EXACT_QTY7 = 2621,
	FID_BID_EXACT_QTY8 = 2622,
	FID_BID_EXACT_QTY9 = 2623,
	FID_BID_EXACT_QTY10 = 2624,

	FID_ASK_EXACT_QTY6 = 2625,
	FID_ASK_EXACT_QTY7 = 2626,
	FID_ASK_EXACT_QTY8 = 2627,
	FID_ASK_EXACT_QTY9 = 2628,
	FID_ASK_EXACT_QTY10 = 2629,

	FID_REV_DB2630 = 2630,
	FID_REV_DB2631 = 2631,
	FID_REV_DB2632 = 2632,
	FID_REV_DB2633 = 2633,
	FID_REV_DB2634 = 2634,
	FID_REV_DB2635 = 2635,
	FID_REV_DB2636 = 2636,
	FID_REV_DB2637 = 2637,
	FID_REV_DB2638 = 2638,
	FID_REV_DB2639 = 2639,

	FID_REV_DB2640 = 2640,
	FID_REV_DB2641 = 2641,
	FID_REV_DB2642 = 2642,
	FID_REV_DB2643 = 2643,
	FID_REV_DB2644 = 2644,
	FID_REV_DB2645 = 2645,
	FID_REV_DB2646 = 2646,
	FID_REV_DB2647 = 2647,
	FID_REV_DB2648 = 2648,
	FID_REV_DB2649 = 2649,

	FID_REV_DB2650 = 2650,
	FID_REV_DB2651 = 2651,
	FID_REV_DB2652 = 2652,
	FID_REV_DB2653 = 2653,
	FID_REV_DB2654 = 2654,
	FID_REV_DB2655 = 2655,
	FID_REV_DB2656 = 2656,
	FID_REV_DB2657 = 2657,
	FID_REV_DB2658 = 2658,
	FID_REV_DB2659 = 2659,

	FID_REV_DB2660 = 2660,
	FID_REV_DB2661 = 2661,
	FID_REV_DB2662 = 2662,
	FID_REV_DB2663 = 2663,
	FID_REV_DB2664 = 2664,
	FID_REV_DB2665 = 2665,
	FID_REV_DB2666 = 2666,
	FID_REV_DB2667 = 2667,
	FID_REV_DB2668 = 2668,
	FID_REV_DB2669 = 2669,

	FID_REV_DB2670 = 2670,
	FID_REV_DB2671 = 2671,
	FID_REV_DB2672 = 2672,
	FID_REV_DB2673 = 2673,
	FID_REV_DB2674 = 2674,
	FID_REV_DB2675 = 2675,
	FID_REV_DB2676 = 2676,
	FID_REV_DB2677 = 2677,
	FID_REV_DB2678 = 2678,
	FID_REV_DB2679 = 2679,

	FID_REV_DB2680 = 2680,
	FID_REV_DB2681 = 2681,
	FID_REV_DB2682 = 2682,
	FID_REV_DB2683 = 2683,
	FID_REV_DB2684 = 2684,
	FID_REV_DB2685 = 2685,
	FID_REV_DB2686 = 2686,
	FID_REV_DB2687 = 2687,
	FID_REV_DB2688 = 2688,
	FID_REV_DB2689 = 2689,

	FID_REV_DB2690 = 2690,
	FID_REV_DB2691 = 2691,
	FID_REV_DB2692 = 2692,
	FID_REV_DB2693 = 2693,
	FID_REV_DB2694 = 2694,
	FID_REV_DB2695 = 2695,
	FID_REV_DB2696 = 2696,
	FID_REV_DB2697 = 2697,
	FID_REV_DB2698 = 2698,
	FID_REV_DB2699 = 2699,

	FID_TRAN_D10_1 = 2700,
	FID_TRAN_D10_2 = 2701,
	FID_TRAN_D10_3 = 2702,
	FID_TRAN_D10_4 = 2703,
	FID_TRAN_D10_5 = 2704,

	FID_TRAN_D12_1 = 2705,
	FID_TRAN_D12_2 = 2706,
	FID_TRAN_D12_3 = 2707,
	FID_TRAN_D12_4 = 2708,
	FID_TRAN_D12_5 = 2709,

	FID_TRAN_D15_1 = 2710,
	FID_TRAN_D15_2 = 2711,
	FID_TRAN_D15_3 = 2712,
	FID_TRAN_D15_4 = 2713,
	FID_TRAN_D15_5 = 2714,

	FID_TRAN_D20_1 = 2715,
	FID_TRAN_D20_2 = 2716,
	FID_TRAN_D20_3 = 2717,
	FID_TRAN_D20_4 = 2718,
	FID_TRAN_D20_5 = 2719,

	FID_TXN_D1 = 2720,
	// 20160804
	FID_REV_UCH2721 = 2721,
	FID_REV_UCH2722 = 2722,
	FID_REV_UCH2723 = 2723,
	FID_REV_UCH2724 = 2724,
	FID_REV_UCH2725 = 2725,
	FID_REV_UCH2726 = 2726,
	FID_REV_UCH2727 = 2727,
	FID_REV_UCH2728 = 2728,
	FID_REV_UCH2729 = 2729,
	FID_REV_UCH2730 = 2730,

	FID_REV_UCH2731 = 2731,
	FID_REV_UCH2732 = 2732,
	FID_REV_UCH2233 = 2733,
	FID_REV_UCH2734 = 2734,
	FID_REV_UCH2735 = 2735,
	FID_REV_UCH2736 = 2736,
	FID_REV_UCH2737 = 2737,
	FID_REV_UCH2738 = 2738,
	FID_REV_UCH2739 = 2739,
	FID_REV_UCH2740 = 2740,

	FID_REV_UCH2741 = 2741,
	FID_REV_UCH2742 = 2742,
	FID_REV_UCH2243 = 2743,
	FID_REV_UCH2744 = 2744,
	FID_REV_UCH2745 = 2745,
	FID_REV_UCH2746 = 2746,
	FID_REV_UCH2747 = 2747,
	FID_REV_UCH2748 = 2748,
	FID_REV_UCH2749 = 2749,
	FID_REV_UCH2750 = 2750,

	FID_REV_UCH2751 = 2751,
	FID_REV_UCH2752 = 2752,
	FID_REV_UCH2253 = 2753,
	FID_REV_UCH2754 = 2754,
	FID_REV_UCH2755 = 2755,
	FID_REV_UCH2756 = 2756,
	FID_REV_UCH2757 = 2757,
	FID_REV_UCH2758 = 2758,
	FID_REV_UCH2759 = 2759,
	FID_REV_UCH2760 = 2760,

	FID_REV_UCH2761 = 2761,
	FID_REV_UCH2762 = 2762,
	FID_REV_UCH2263 = 2763,
	FID_REV_UCH2764 = 2764,
	FID_REV_UCH2765 = 2765,
	FID_REV_UCH2766 = 2766,
	FID_REV_UCH2767 = 2767,
	FID_REV_UCH2768 = 2768,
	FID_REV_UCH2769 = 2769,
	FID_REV_UCH2770 = 2770,

	FID_REV_UCH2771 = 2771,
	FID_REV_UCH2772 = 2772,
	FID_REV_UCH2773 = 2773,
	FID_REV_UCH2774 = 2774,
	FID_REV_UCH2775 = 2775,
	FID_REV_UCH2776 = 2776,
	FID_REV_UCH2777 = 2777,
	FID_REV_UCH2778 = 2778,
	FID_REV_UCH2779 = 2779,
	FID_REV_UCH2780 = 2780,

	FID_REV_UCH2781 = 2781,
	FID_REV_UCH2782 = 2782,
	FID_REV_UCH2283 = 2783,
	FID_REV_UCH2784 = 2784,
	FID_REV_UCH2785 = 2785,
	FID_REV_UCH2786 = 2786,
	FID_REV_UCH2787 = 2787,
	FID_REV_UCH2788 = 2788,
	FID_REV_UCH2789 = 2789,
	FID_REV_UCH2790 = 2790,

	FID_REV_UCH2791 = 2791,
	FID_REV_UCH2792 = 2792,
	FID_REV_UCH2293 = 2793,
	FID_REV_UCH2794 = 2794,
	FID_REV_UCH2795 = 2795,
	FID_REV_UCH2796 = 2796,
	FID_REV_UCH2797 = 2797,
	FID_REV_UCH2798 = 2798,
	FID_REV_UCH2799 = 2799,
	FID_REV_UCH2800 = 2800,

	FID_REV_UCH2801 = 2801,
	FID_REV_UCH2802 = 2802,
	FID_REV_UCH2803 = 2803,
	FID_REV_UCH2804 = 2804,
	FID_REV_UCH2805 = 2805,
	FID_REV_UCH2806 = 2806,
	FID_REV_UCH2807 = 2807,
	FID_REV_UCH2808 = 2808,
	FID_REV_UCH2809 = 2809,
	FID_REV_UCH2810 = 2810,

	FID_REV_UCH2811 = 2811,
	FID_REV_UCH2812 = 2812,
	FID_REV_UCH2813 = 2813,
	FID_REV_UCH2814 = 2814,
	FID_REV_UCH2815 = 2815,
	FID_REV_UCH2816 = 2816,
	FID_REV_UCH2817 = 2817,
	FID_REV_UCH2818 = 2818,
	FID_REV_UCH2819 = 2819,
	FID_REV_UCH2820 = 2820,

	FID_REV_UFT2821 = 2821,
	FID_REV_UFT2822 = 2822,
	FID_REV_UFT2823 = 2823,
	FID_REV_UFT2824 = 2824,
	FID_REV_UFT2825 = 2825,
	FID_REV_UFT2826 = 2826,
	FID_REV_UFT2827 = 2827,
	FID_REV_UFT2828 = 2828,
	FID_REV_UFT2829 = 2829,
	FID_REV_UFT2830 = 2830,

	FID_REV_UFT2831 = 2831,
	FID_REV_UFT2832 = 2832,
	FID_REV_UFT2833 = 2833,
	FID_REV_UFT2834 = 2834,
	FID_REV_UFT2835 = 2835,
	FID_REV_UFT2836 = 2836,
	FID_REV_UFT2837 = 2837,
	FID_REV_UFT2838 = 2838,
	FID_REV_UFT2839 = 2839,
	FID_REV_UFT2840 = 2840,

	FID_REV_UFT2841 = 2841,
	FID_REV_UFT2842 = 2842,
	FID_REV_UFT2843 = 2843,
	FID_REV_UFT2844 = 2844,
	FID_REV_UFT2845 = 2845,
	FID_REV_UFT2846 = 2846,
	FID_REV_UFT2847 = 2847,
	FID_REV_UFT2848 = 2848,
	FID_REV_UFT2849 = 2849,
	FID_REV_UFT2850 = 2850,

	FID_REV_UFT2851 = 2851,
	FID_REV_UFT2852 = 2852,
	FID_REV_UFT2853 = 2853,
	FID_REV_UFT2854 = 2854,
	FID_REV_UFT2855 = 2855,
	FID_REV_UFT2856 = 2856,
	FID_REV_UFT2857 = 2857,
	FID_REV_UFT2858 = 2858,
	FID_REV_UFT2859 = 2859,
	FID_REV_UFT2860 = 2860,

	FID_REV_UFT2861 = 2861,
	FID_REV_UFT2862 = 2862,
	FID_REV_UFT2863 = 2863,
	FID_REV_UFT2864 = 2864,
	FID_REV_UFT2865 = 2865,
	FID_REV_UFT2866 = 2866,
	FID_REV_UFT2867 = 2867,
	FID_REV_UFT2868 = 2868,
	FID_REV_UFT2869 = 2869,
	FID_REV_UFT2870 = 2870,

	FID_REV_UFT2871 = 2871,
	FID_REV_UFT2872 = 2872,
	FID_REV_UFT2873 = 2873,
	FID_REV_UFT2874 = 2874,
	FID_REV_UFT2875 = 2875,
	FID_REV_UFT2876 = 2876,
	FID_REV_UFT2877 = 2877,
	FID_REV_UFT2878 = 2878,
	FID_REV_UFT2879 = 2879,
	FID_REV_UFT2880 = 2880,

	FID_REV_UFT2881 = 2881,
	FID_REV_UFT2882 = 2882,
	FID_REV_UFT2883 = 2883,
	FID_REV_UFT2884 = 2884,
	FID_REV_UFT2885 = 2885,
	FID_REV_UFT2886 = 2886,
	FID_REV_UFT2887 = 2887,
	FID_REV_UFT2888 = 2888,
	FID_REV_UFT2889 = 2889,
	FID_REV_UFT2890 = 2890,

	FID_REV_UFT2891 = 2891,
	FID_REV_UFT2892 = 2892,
	FID_REV_UFT2893 = 2893,
	FID_REV_UFT2894 = 2894,
	FID_REV_UFT2895 = 2895,
	FID_REV_UFT2896 = 2896,
	FID_REV_UFT2897 = 2897,
	FID_REV_UFT2898 = 2898,
	FID_REV_UFT2899 = 2899,
	FID_REV_UFT2900 = 2900,

	FID_REV_UFT2901 = 2901,
	FID_REV_UFT2902 = 2902,
	FID_REV_UFT2903 = 2903,
	FID_REV_UFT2904 = 2904,
	FID_REV_UFT2905 = 2905,
	FID_REV_UFT2906 = 2906,
	FID_REV_UFT2907 = 2907,
	FID_REV_UFT2908 = 2908,
	FID_REV_UFT2909 = 2909,
	FID_REV_UFT2910 = 2910,

	FID_REV_UFT2911 = 2911,
	FID_REV_UFT2912 = 2912,
	FID_REV_UFT2913 = 2913,
	FID_REV_UFT2914 = 2914,
	FID_REV_UFT2915 = 2915,
	FID_REV_UFT2916 = 2916,
	FID_REV_UFT2917 = 2917,
	FID_REV_UFT2918 = 2918,
	FID_REV_UFT2919 = 2919,
	FID_REV_UFT2920 = 2920,

	FID_REV_DB2921 = 2921,
	FID_REV_DB2922 = 2922,
	FID_REV_DB2923 = 2923,
	FID_REV_DB2924 = 2924,
	FID_REV_DB2925 = 2925,
	FID_REV_DB2926 = 2926,
	FID_REV_DB2927 = 2927,
	FID_REV_DB2928 = 2928,
	FID_REV_DB2929 = 2929,
	FID_REV_DB2930 = 2930,

	FID_REV_DB2931 = 2931,
	FID_REV_DB2932 = 2932,
	FID_REV_DB2933 = 2933,
	FID_REV_DB2934 = 2934,
	FID_REV_DB2935 = 2935,
	FID_REV_DB2936 = 2936,
	FID_REV_DB2937 = 2937,
	FID_REV_DB2938 = 2938,
	FID_REV_DB2939 = 2939,
	FID_REV_DB2940 = 2940,

	FID_REV_DB2941 = 2941,
	FID_REV_DB2942 = 2942,
	FID_REV_DB2943 = 2943,
	FID_REV_DB2944 = 2944,
	FID_REV_DB2945 = 2945,
	FID_REV_DB2946 = 2946,
	FID_REV_DB2947 = 2947,
	FID_REV_DB2948 = 2948,
	FID_REV_DB2949 = 2949,
	FID_REV_DB2950 = 2950,

	FID_REV_DB2951 = 2951,
	FID_REV_DB2952 = 2952,
	FID_REV_DB2953 = 2953,
	FID_REV_DB2954 = 2954,
	FID_REV_DB2955 = 2955,
	FID_REV_DB2956 = 2956,
	FID_REV_DB2957 = 2957,
	FID_REV_DB2958 = 2958,
	FID_REV_DB2959 = 2959,
	FID_REV_DB2960 = 2960,

	FID_REV_DB2961 = 2961,
	FID_REV_DB2962 = 2962,
	FID_REV_DB2963 = 2963,
	FID_REV_DB2964 = 2964,
	FID_REV_DB2965 = 2965,
	FID_REV_DB2966 = 2966,
	FID_REV_DB2967 = 2967,
	FID_REV_DB2968 = 2968,
	FID_REV_DB2969 = 2969,
	FID_REV_DB2970 = 2970,

	FID_GEN_TXT2971 = 2971,
	FID_GEN_TXT2972 = 2972,
	FID_GEN_TXT2973 = 2973,
	FID_GEN_TXT2974 = 2974,
	FID_GEN_TXT2975 = 2975,
	FID_GEN_TXT2976 = 2976,
	FID_GEN_TXT2977 = 2977,
	FID_GEN_TXT2978 = 2978,
	FID_GEN_TXT2979 = 2979,
	FID_GEN_TXT2980 = 2980,

	FID_GEN_TXT2981 = 2981,
	FID_GEN_TXT2982 = 2982,
	FID_GEN_TXT2983 = 2983,
	FID_GEN_TXT2984 = 2984,
	FID_GEN_TXT2985 = 2985,
	FID_GEN_TXT2986 = 2986,
	FID_GEN_TXT2987 = 2987,
	FID_GEN_TXT2988 = 2988,
	FID_GEN_TXT2989 = 2989,
	FID_GEN_TXT2990 = 2990,

	FID_GEN_TXT2991 = 2991,
	FID_GEN_TXT2992 = 2992,
	FID_GEN_TXT2993 = 2993,
	FID_GEN_TXT2994 = 2994,
	FID_GEN_TXT2995 = 2995,
	FID_GEN_TXT2996 = 2996,
	FID_GEN_TXT2997 = 2997,
	FID_GEN_TXT2998 = 2998,
	FID_GEN_TXT2999 = 2999,
	FID_GEN_TXT3000 = 3000,

	FID_GEN_TXT3001 = 3001,
	FID_GEN_TXT3002 = 3002,
	FID_GEN_TXT3003 = 3003,
	FID_GEN_TXT3004 = 3004,
	FID_GEN_TXT3005 = 3005,
	FID_GEN_TXT3006 = 3006,
	FID_GEN_TXT3007 = 3007,
	FID_GEN_TXT3008 = 3008,
	FID_GEN_TXT3009 = 3009,
	FID_GEN_TXT3010 = 3010,

	FID_GEN_TXT3011 = 3011,
	FID_GEN_TXT3012 = 3012,
	FID_GEN_TXT3013 = 3013,
	FID_GEN_TXT3014 = 3014,
	FID_GEN_TXT3015 = 3015,
	FID_GEN_TXT3016 = 3016,
	FID_GEN_TXT3017 = 3017,
	FID_GEN_TXT3018 = 3018,
	FID_GEN_TXT3019 = 3019,
	FID_GEN_TXT3020 = 3020,

	FID_REV_UL3021 = 3021,
	FID_REV_UL3022 = 3022,
	FID_REV_UL3023 = 3023,
	FID_REV_UL3024 = 3024,
	FID_REV_UL3025 = 3025,
	FID_REV_UL3026 = 3026,
	FID_REV_UL3027 = 3027,
	FID_REV_UL3028 = 3028,
	FID_REV_UL3029 = 3029,
	FID_REV_UL3030 = 3030,

	FID_REV_UL3031 = 3031,
	FID_REV_UL3032 = 3032,
	FID_REV_UL3033 = 3033,
	FID_REV_UL3034 = 3034,
	FID_REV_UL3035 = 3035,
	FID_REV_UL3036 = 3036,
	FID_REV_UL3037 = 3037,
	FID_REV_UL3038 = 3038,
	FID_REV_UL3039 = 3039,
	FID_REV_UL3040 = 3040,

	FID_REV_UL3041 = 3041,
	FID_REV_UL3042 = 3042,
	FID_REV_UL3043 = 3043,
	FID_REV_UL3044 = 3044,
	FID_REV_UL3045 = 3045,
	FID_REV_UL3046 = 3046,
	FID_REV_UL3047 = 3047,
	FID_REV_UL3048 = 3048,
	FID_REV_UL3049 = 3049,
	FID_REV_UL3050 = 3050,

	FID_REV_UL3051 = 3051,
	FID_REV_UL3052 = 3052,
	FID_REV_UL3053 = 3053,
	FID_REV_UL3054 = 3054,
	FID_REV_UL3055 = 3055,
	FID_REV_UL3056 = 3056,
	FID_REV_UL3057 = 3057,
	FID_REV_UL3058 = 3058,
	FID_REV_UL3059 = 3059,
	FID_REV_UL3060 = 3060,

	FID_REV_UL3061 = 3061,
	FID_REV_UL3062 = 3062,
	FID_REV_UL3063 = 3063,
	FID_REV_UL3064 = 3064,
	FID_REV_UL3065 = 3065,
	FID_REV_UL3066 = 3066,
	FID_REV_UL3067 = 3067,
	FID_REV_UL3068 = 3068,
	FID_REV_UL3069 = 3069,
	FID_REV_UL3070 = 3070,

	FID_REV_FT3071 = 3071,
	FID_REV_FT3072 = 3072,
	FID_REV_FT3073 = 3073,
	FID_REV_FT3074 = 3074,
	FID_REV_FT3075 = 3075,
	FID_REV_FT3076 = 3076,
	FID_REV_FT3077 = 3077,
	FID_REV_FT3078 = 3078,
	FID_REV_FT3079 = 3079,
	FID_REV_FT3080 = 3080,

	FID_REV_FT3081 = 3081,
	FID_REV_FT3082 = 3082,
	FID_REV_FT3083 = 3083,
	FID_REV_FT3084 = 3084,
	FID_REV_FT3085 = 3085,
	FID_REV_FT3086 = 3086,
	FID_REV_FT3087 = 3087,
	FID_REV_FT3088 = 3088,
	FID_REV_FT3089 = 3089,
	FID_REV_FT3090 = 3090,

	FID_REV_LG3091 = 3091,
	FID_REV_LG3092 = 3092,
	FID_REV_LG3093 = 3093,
	FID_REV_LG3094 = 3094,
	FID_REV_LG3095 = 3095,
	FID_REV_LG3096 = 3096,
	FID_REV_LG3097 = 3097,
	FID_REV_LG3098 = 3098,
	FID_REV_LG3099 = 3099,
	FID_REV_LG3100 = 3100,

	FID_REV_PG3101 = 3101,
	FID_REV_PG3102 = 3102,
	FID_REV_PG3103 = 3103,
	FID_REV_PG3104 = 3104,
	FID_REV_PG3105 = 3105,
	FID_REV_PG3106 = 3106,
	FID_REV_PG3107 = 3107,
	FID_REV_PG3108 = 3108,
	FID_REV_PG3109 = 3109,
	FID_REV_PG3110 = 3110,

	FID_REV_PG3111 = 3111,
	FID_REV_PG3112 = 3112,
	FID_REV_PG3113 = 3113,
	FID_REV_PG3114 = 3114,
	FID_REV_PG3115 = 3115,
	FID_REV_PG3116 = 3116,
	FID_REV_PG3117 = 3117,
	FID_REV_PG3118 = 3118,
	FID_REV_PG3119 = 3119,
	FID_REV_PG3120 = 3120,

	FID_REV_SEC3121 = 3121,
	FID_REV_SEC3122 = 3122,
	FID_REV_SEC3123 = 3123,
	FID_REV_SEC3124 = 3124,
	FID_REV_SEC3125 = 3125,
	FID_REV_SEC3126 = 3126,
	FID_REV_SEC3127 = 3127,
	FID_REV_SEC3128 = 3128,
	FID_REV_SEC3129 = 3129,
	FID_REV_SEC3130 = 3130,

	FID_REV_SEC3131 = 3131,
	FID_REV_SEC3132 = 3132,
	FID_REV_SEC3133 = 3133,
	FID_REV_SEC3134 = 3134,
	FID_REV_SEC3135 = 3135,
	FID_REV_SEC3136 = 3136,
	FID_REV_SEC3137 = 3137,
	FID_REV_SEC3138 = 3138,
	FID_REV_SEC3139 = 3139,
	FID_REV_SEC3140 = 3140,

	FID_REV_SEC3141 = 3141,
	FID_REV_SEC3142 = 3142,
	FID_REV_SEC3143 = 3143,
	FID_REV_SEC3144 = 3144,
	FID_REV_SEC3145 = 3145,
	FID_REV_SEC3146 = 3146,
	FID_REV_SEC3147 = 3147,
	FID_REV_SEC3148 = 3148,
	FID_REV_SEC3149 = 3149,
	FID_REV_SEC3150 = 3150,

	FID_REV_SEC3151 = 3151,
	FID_REV_SEC3152 = 3152,
	FID_REV_SEC3153 = 3153,
	FID_REV_SEC3154 = 3154,
	FID_REV_SEC3155 = 3155,
	FID_REV_SEC3156 = 3156,
	FID_REV_SEC3157 = 3157,
	FID_REV_SEC3158 = 3158,
	FID_REV_SEC3159 = 3159,
	FID_REV_SEC3160 = 3160,

	FID_REV_SEC3161 = 3161,
	FID_REV_SEC3162 = 3162,
	FID_REV_SEC3163 = 3163,
	FID_REV_SEC3164 = 3164,
	FID_REV_SEC3165 = 3165,
	FID_REV_SEC3166 = 3166,
	FID_REV_SEC3167 = 3167,
	FID_REV_SEC3168 = 3168,
	FID_REV_SEC3169 = 3169,
	FID_REV_SEC3170 = 3170,

	FID_REV_MIN3171 = 3171,
	FID_REV_MIN3172 = 3172,
	FID_REV_MIN3173 = 3173,
	FID_REV_MIN3174 = 3174,
	FID_REV_MIN3175 = 3175,
	FID_REV_MIN3176 = 3176,
	FID_REV_MIN3177 = 3177,
	FID_REV_MIN3178 = 3178,
	FID_REV_MIN3179 = 3179,
	FID_REV_MIN3180 = 3180,

	FID_REV_MIN3181 = 3181,
	FID_REV_MIN3182 = 3182,
	FID_REV_MIN3183 = 3183,
	FID_REV_MIN3184 = 3184,
	FID_REV_MIN3185 = 3185,
	FID_REV_MIN3186 = 3186,
	FID_REV_MIN3187 = 3187,
	FID_REV_MIN3188 = 3188,
	FID_REV_MIN3189 = 3189,
	FID_REV_MIN3190 = 3190,

	FID_FLBL_3191 = 3191,
	FID_FLBL_3192 = 3192,
	FID_FLBL_3193 = 3193,
	FID_FLBL_3194 = 3194,
	FID_FLBL_3195 = 3195,
	FID_FLBL_3196 = 3196,
	FID_FLBL_3197 = 3197,
	FID_FLBL_3198 = 3198,
	FID_FLBL_3199 = 3199,
	FID_FLBL_3200 = 3200,

	FID_LST3201 = 3201,
	FID_LST3202 = 3202,
	FID_LST3203 = 3203,
	FID_LST3204 = 3204,
	FID_LST3205 = 3205,

	FID_QL_3206 = 3206,
	FID_QL_3207 = 3207,
	FID_QL_3208 = 3208,
	FID_QL_3209 = 3209,
	FID_QL_3210 = 3210,
	FID_QL_3211 = 3211,
	FID_QL_3212 = 3212,
	FID_QL_3213 = 3213,
	FID_QL_3214 = 3214,
	FID_QL_3215 = 3215,
	FID_QL_3216 = 3216,
	FID_QL_3217 = 3217,
	FID_QL_3218 = 3218,
	FID_QL_3219 = 3219,
	FID_QL_3220 = 3220,

	FID_SLINK_3221 = 3221,
	FID_SLINK_3222 = 3222,
	FID_SLINK_3223 = 3223,
	FID_SLINK_3224 = 3224,
	FID_SLINK_3225 = 3225,
	FID_SLINK_3226 = 3226,
	FID_SLINK_3227 = 3227,
	FID_SLINK_3228 = 3228,
	FID_SLINK_3229 = 3229,
	FID_SLINK_3230 = 3230,
	FID_END,
} FID_DEFINITION;

    
    typedef enum {
      CUR_AFA = 4,
      CUR_ALL = 8,
      CUR_DZD = 12,
      CUR_ADP = 20,
      CUR_AON = 24,
      CUR_ARS = 32,
      CUR_AUD = 36,
      CUR_AUc = 37,
      CUR_ATS = 40,
      CUR_BSD = 44,
      CUR_BHD = 48,
      CUR_BDT = 50,
      CUR_BBD = 52,
      CUR_BEF = 56,
      CUR_BMD = 60,
      CUR_BTN = 64,
      CUR_BOB = 68,
      CUR_BAD = 70,
      CUR_BWP = 72,
      CUR_BRL = 76,
      CUR_BZD = 84,
      CUR_SBD = 90,
      CUR_BND = 96,
      CUR_BGL = 100,
      CUR_MMK = 104,
      CUR_BIF = 108,
      CUR_KHR = 116,
      CUR_CAD = 124,
      CUR_CVE = 132,
      CUR_KYD = 136,
      CUR_LKR = 144,
      CUR_CLP = 152,
      CUR_CNY = 156,
      CUR_COP = 170,
      CUR_KMF = 174,
      CUR_ZRN = 180,
      CUR_CRC = 188,
      CUR_HRD = 191,
      CUR_CUP = 192,
      CUR_CYP = 196,
      CUR_200 = 200,
      CUR_CZK = 203,
      CUR_DKK = 208,
      CUR_DOP = 214,
      CUR_ECS = 218,
      CUR_SVC = 222,
      CUR_EEK = 226,
      CUR_ETB = 230,
      CUR_FKP = 238,
      CUR_FJD = 242,
      CUR_FIM = 246,
      CUR_FRF = 250,
      CUR_DJF = 262,
      CUR_GMD = 270,
      CUR_DEM = 280,
      CUR_GHC = 288,
      CUR_GIP = 292,
      CUR_GRD = 300,
      CUR_GTQ = 320,
      CUR_GNF = 324,
      CUR_GYD = 328,
      CUR_HTG = 332,
      CUR_HNL = 340,
      CUR_HKD = 344,
      CUR_HKc = 345,
      CUR_HUF = 348,
      CUR_ISK = 352,
      CUR_INR = 356,
      CUR_IDR = 360,
      CUR_IRR = 364,
      CUR_IQD = 368,
      CUR_IEP = 372,
      CUR_IEp = 373,
      CUR_ILS = 376,
      CUR_ITL = 380,
      CUR_JMD = 388,
      CUR_JPY = 392,
      CUR_JOD = 400,
      CUR_KES = 404,
      CUR_KPW = 408,
      CUR_KRW = 410,
      CUR_KWD = 414,
      CUR_LAK = 418,
      CUR_LBP = 422,
      CUR_LSL = 426,
      CUR_LVR = 428,
      CUR_LRD = 430,
      CUR_LYD = 434,
      CUR_LTL = 440,
      CUR_LUF = 442,
      CUR_MOP = 446,
      CUR_MGF = 450,
      CUR_MWK = 454,
      CUR_MYR = 458,
      CUR_MYc = 459,
      CUR_MVR = 462,
      CUR_MLF = 466,
      CUR_MTL = 470,
      CUR_MRO = 478,
      CUR_MUR = 480,
      CUR_MXN = 484,
      CUR_MNT = 496,
      CUR_MDL = 498,
      CUR_MAD = 504,
      CUR_MZM = 508,
      CUR_OMR = 512,
      CUR_NAD = 516,
      CUR_NPR = 524,
      CUR_NLG = 528,
      CUR_ANG = 532,
      CUR_AWG = 533,
      CUR_VUV = 548,
      CUR_NZD = 554,
      CUR_NIO = 558,
      CUR_NGN = 566,
      CUR_NOK = 578,
      CUR_PKR = 586,
      CUR_PAB = 590,
      CUR_PGK = 598,
      CUR_PYG = 600,
      CUR_PEN = 604,
      CUR_PHP = 608,
      CUR_PLZ = 616,
      CUR_PTE = 620,
      CUR_GWP = 624,
      CUR_TPE = 626,
      CUR_QAR = 634,
      CUR_ROL = 642,
      CUR_RWF = 646,
      CUR_SHP = 654,
      CUR_STD = 678,
      CUR_SAR = 682,
      CUR_SCR = 690,
      CUR_SLL = 694,
      CUR_SGD = 702,
      CUR_SKK = 703,
      CUR_VND = 704,
      CUR_SIT = 705,
      CUR_SOS = 706,
      CUR_ZAR = 710,
      CUR_ZWD = 716,
      CUR_720 = 720,
      CUR_ESP = 724,
      CUR_SDD = 736,
      CUR_SRG = 740,
      CUR_SZL = 748,
      CUR_SEK = 752,
      CUR_CHF = 756,
      CUR_SYP = 760,
      CUR_THB = 764,
      CUR_TOP = 776,
      CUR_TTD = 780,
      CUR_AED = 784,
      CUR_TND = 788,
      CUR_TRL = 792,
      CUR_TMM = 795,
      CUR_UGX = 800,
      CUR_UAK = 804,
      CUR_MKD = 807,
      CUR_RUR = 810,
      CUR_EGP = 818,
      CUR_GBP = 826,
      CUR_GBp = 827,
      CUR_TZS = 834,
      CUR_USD = 840,
      CUR_USc = 841,
      CUR_UYU = 858,
      CUR_VEB = 862,
      CUR_WST = 882,
      CUR_YER = 886,
      CUR_890 = 890,
      CUR_YUM = 891,
      CUR_ZMK = 894,
      CUR_TWD = 901,
      CUR_XAF = 950,
      CUR_XCD = 951,
      CUR_XOF = 952,
      CUR_XPF = 953,
      CUR_XEU = 954,
      CUR_XBA = 955,
      CUR_XBB = 956,
      CUR_XBC = 957,
      CUR_XBD = 958,
      CUR_XAU = 959,
      CUR_XDR = 960,
      CUR_XAG = 961,
      CUR_XPT = 962,
      CUR_XTS = 963,
      CUR_XPD = 964,
      CUR_EUR = 978,
      CUR_UAH = 980,
      CUR_PLN = 985,
      CUR_CLF = 990,
      CUR_ZAL = 991,
      CUR_ESB = 995,
      CUR_ESA = 996,
      CUR_USN = 997,
      CUR_USS = 998,
      CUR_XXX = 999,
      CUR_tst = 2000,
      CUR_CAc = 2002,
      CUR_NZc = 2006,
      CUR_SGc = 2007,
      CUR_ZAc = 2010,
      CUR_ZWc = 2011,
      CUR_EUc = 2012,
      CUR_NAc = 2013,
}CURRENCYTYPE;

typedef enum {
	NGN_CHAR		=		1,
	NGN_UNICODE		=		2,
	NGN_SHORT		=		3,
	NGN_USHORT		=		4,
	NGN_LONG		=		5,
	NGN_ULONG		=		6,
	NGN_FLOAT		=		7,
	NGN_UFLOAT		=		8,
	NGN_DOUBLE		=		9,
	NGN_UDOUBLE		=		10,
	NGN_CHARARRAY	=		11,
	NGN_MCHARARRAY	=		12,
	NGN_BDATEYEAR	=		13,
	NGN_BDATEMONTH	=		14,
	NGN_BTIMEMIN	=		15,
	NGN_BTIMESEC	=		16,
	NGN_BTIMERANGES =		17,
	NGN_TRAN		=		18,
	NGN_TXN			=		19,
	NGN_SHRORDLST	=		20,
	NGN_PRCVOL		=		21,
	NGN_BKRQUE		=		22,
	NGN_LINK		=		23,
	NGN_WLINK		=		24,
	NGN_YLABEL		=		25,
	NGN_XMTCLABEL	=		26,
	NGN_XDTCLABEL	=		27,
	NGN_MTCPOINTS	=		28,
	NGN_MTCVAL		=		29,
	NGN_DTCPOINTS	=		30,
	NGN_HISVAL		=		31,
	NGN_FIELDLIST	=		32,
	NGN_FIELDLABEL	=		33,
	NGN_INFOMSG		=		34,
	NGN_HEADLINE	=		35,
	NGN_HLINK		=		36,
	NGN_MSHRORDLST	=		37,
	NGN_SPRTBL		=		38,
	NGN_QUOTELIST	=		39,
	NGN_MTCTICKS	=		40,
	NGN_MTCV		=		41,
	NGN_YHEADLINE	=		42,
	NGN_OBKRQUE		=		43,
	NGN_KMULTIPLE	=		44,
	NGN_10KMULTIPLE	=		45,
    NGN_BQUEVOSN    =       46,
	NGN_MTCPTS		=		47,
	NGN_MTCF		=		48,
    NGN_PRCVOLWSEQ	=		50,
	NGN_TRAN_D		=		51,
	NGN_TXN_D		=		52,
	NGN_DATATYPE_END = 53,
} DATA_TYPE;

typedef enum {
	REC_UNDEFINED		=		0,
	REC_EQUITY			=		1,
	REC_STOCK			=		1,
	REC_WARRANT			=		2,
	REC_BASKETWNT		=		3,
	REC_INDEX			=		4,
	REC_BOND			=		5,
	REC_TRUST			=		6,
	REC_NEWSHL			=		7,
	REC_FUTURE			=		8,
	REC_TELETEXT		=		9,
	REC_DERIVATIVES		=		10,
	REC_FOREX			=		11,
	REC_FUNDNOTE		=		12,
	REC_MTC				=		13,
	REC_QL				=		14,
	REC_PRSEAS			=		15,
	REC_PRSFUTURES		=		16,
	REC_PRSOPTIONS		=		17,
	REC_PRSOPTLINK		=		18,
	REC_ALIAS			=		20,
	REC_CHAIN			=		21,
	REC_MTCDEF			=		22,
	REC_INFOBAR			=		23,
	REC_TOPRANKING		=		24,
	REC_TELETEXTLIST	=		25,
	REC_INDEXCONS		=		26,
	REC_QUOTELIST		=		27,
	REC_NEWSDEFITION	=		28,
	REC_STOCKSELECTION	=		29,
	REC_SERVPERMISSION	=		30,
	REC_SERVPACKAGE		=		31,
	REC_INDEXCHART		=		32,
	REC_FUNDAMENTAL		=		33,
	REC_FUTURELIST		=		34,
    REC_OPTIONS         =       36,
    REC_NEWSSOURCEDEF   =       37,
    REC_NEWFUTURELIST   =       38,
	REC_WRTSUMMARYDEF	=       39,
    REC_RTDPERMISSION	=       40,
	REC_WRTLINKDEF		=		41,
	REC_WRTEXOTICDEF	=		42,
	REC_STOCKSECTORDEF	=		44,
	REC_WRTSECTORDEF	=		45,
	REC_SHORTSELLDEF	=		46,
	REC_SHORTSELLLINK	=		47,
	REC_INDSTRYSCTR		=		48,
	REC_TOPRANKINGFF	=		49,
	REC_TRSOURCEDEF		=		50,
	REC_AHPERFORMANCE	=		51,
	REC_ASTOCK			=		52,
	REC_SMP_AHPERFORM	=		53,
	REC_OVERSEAINDEX	=		54,
	REC_COMMODITY		=		55,
	REC_LPCONTRIBUTOR	=		56
} RECORD_TYPE;

/////////////////////////////////////////////////////////////////////////////
//
// Class      : datatype
// Description: Base class for all data type class
//
class datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	datatype():m_pbyData(NULL), m_nDataLen(0), m_bDataChanged(TRUE), m_nBufferSize(512){};

	// -------------------------------------------------------------------------
	// Constructor - construct the datatype by data stream
	datatype(byte* pbyData):m_pbyData(NULL), m_nDataLen(0), m_bDataChanged(TRUE), m_nBufferSize(512){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
	virtual ~datatype();

// Operations
	// -------------------------------------------------------------------------
	// Get the Data byte stream
	virtual byte* GetData()	{return m_pbyData;}

	// -------------------------------------------------------------------------
	// Get the total data length
	virtual unsigned short GetDataLen()	{return m_nDataLen;}

	// -------------------------------------------------------------------------
	// Init Object from byte stream
	virtual bool Init(byte* pbyData)	{return TRUE;}

protected:
	byte*		m_pbyData;
	unsigned short m_nDataLen;
	unsigned short m_nBufferSize;
	bool		m_bDataChanged;

// Operation	
	// -------------------------------------------------------------------------
	// Clear memory
	virtual void ClearData();
};

// Class      : datatype
// -------------------------------------------------------------------------
// Destructor
inline datatype::~datatype()
{
	ClearData();
}

// Class      : datatype
// -------------------------------------------------------------------------
// ClearData
inline void datatype::ClearData()
{
	if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
//
// Tfid structure 
// Each fid in the CfidDatabase is Defined by Tfid structure
//
struct Tfid
{
	short	nFIDCode;						// Fid Code
	char	cFIDName[MAX_FID_NAME];			// Fid Name
	short	nTypeCode;						// Data Type
	short	nPriority;						// Priority
//	char	cGroup;							// Field group
//	char	cRippleTo[8];					// Ripple to other field
//	short	nVector;						// Vector position
};

/////////////////////////////////////////////////////////////////////////////
//
// Class      : fidDatabase
// Description: 
//
class fidDatabase
{
public:
	// -------------------------------------------------------------------------
	// Constructor - create the fid database from the fidtable
	fidDatabase();

	// -------------------------------------------------------------------------
	// Default Destructor
	virtual ~fidDatabase();

// Operations
	// -------------------------------------------------------------------------
	// Check the fidDatabase is constructed correctly or not
	BOOL		isOkay()		const					{return _okay;}

	// -------------------------------------------------------------------------
	// Get total number of Fids in the fidDatabase
	int			GetFidCount() 	const					{return numFidIds;}

	// -------------------------------------------------------------------------
	// Get the Maximum fid number
	int			GetMaxFid() 	const					{return maxFidId;}

	// -------------------------------------------------------------------------
	// Get the Minimum fid number
	int			GetMinFid() 	const					{return minFidId;}

	// -------------------------------------------------------------------------
	// Get the Fid Data according to the Fid Code
	const Tfid* GetFid(short nFidCode) const;

	// -------------------------------------------------------------------------
	// Get the Fid Name according to the Fid Code
	const char* GetFidName(short nFidCode) const;

	// -------------------------------------------------------------------------
	// Get the Type Code of the Fid according to the Fid Code
	short GetFidType(short nFidCode) const;

	// -------------------------------------------------------------------------
	// Get the Type Code of the Fid according to the Fid Code
	short GetFidPriority(short nFidCode) const;

	// -------------------------------------------------------------------------
	// Get the Group number of the Fid according to the Fid Code
//	const char GetFidGroup(short nFidCode) const;

	// -------------------------------------------------------------------------
	// Get the vector position of the Fid according to the Fid Code
//	short GetFidVector(short nFidCode) const;

	// -------------------------------------------------------------------------
	// Get the Ripple Fid code of the Fid according to the Fid Code
//	const char* GetFidRipple(short nFidCode) const;

protected:
// Attributes
	static bool	_okay;
	static int 	numFidIds;
	static Tfid* fidArray;
	static int 	maxFidId;
	static int	minFidId;
    static long  rArrayCount;
};


/////////////////////////////////////////////////////////////////////////////
//
// Class      : CharArray
// Description: Character Array Type (Data Type D11)
//
class CharArray : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	CharArray():m_byLen(0), 
				m_byPos(0), 
				m_bySq(0), 
				m_pbyString(NULL){m_nDataLen = 4;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	CharArray(byte* pbyData):m_byLen(0), 
							m_byPos(0), 
							m_bySq(0), 
							m_pbyString(NULL){Init(pbyData);}
	
	// -------------------------------------------------------------------------
	// Constructor - by string
	CharArray(char* pcString, byte byPos, byte bySq);

	// -------------------------------------------------------------------------
	// Default Destructor
	virtual ~CharArray();

// Operations
	// -------------------------------------------------------------------------
	// Get the Sequence Number
	byte GetSq()	{return m_bySq;}

	// -------------------------------------------------------------------------
	// Get the Position
	byte GetPos()	{return m_byPos;}

	// -------------------------------------------------------------------------
	// Get the Length
	byte GetLen()	{return m_byLen;}

	// -------------------------------------------------------------------------
	// Get the String
	const byte* GetString()	{return m_pbyString;}

	// -------------------------------------------------------------------------
	// Set the Sequence Number
	void SetSq(byte bySq);

	// -------------------------------------------------------------------------
	// Set the Position
	void SetPos(byte byPos);
	// -------------------------------------------------------------------------
	// Set the Length
	void SetLen(byte byLen);

	// -------------------------------------------------------------------------
	// Set the String
	void SetString(byte* pbyString);

	static unsigned short GetByteLen(byte * pbyData) {
			unsigned short len = *(pbyData + 2); 
			return len + 4;
	};

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the CharArray
	bool Init(byte* pbyData);

protected:
// Operation
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();

private:
// Attributes
	byte		m_bySq;
	byte		m_byPos;
	byte		m_byLen;
	byte*		m_pbyString;
};

// -------------------------------------------------------------------------
// Constructor - by string
inline CharArray::CharArray(char* pcString, byte byPos, byte bySq)
{
	m_pbyData = NULL;
	m_bySq = 0;
	m_byPos = 0;
	m_byLen = 0;
	m_pbyString = NULL;

	if (!pcString)
		return;

	m_byLen = strlen(pcString);
	m_pbyString = new byte[m_byLen+1];
	memset(m_pbyString, 0, m_byLen+1);
	memcpy(m_pbyString, pcString, m_byLen);
	m_byPos = byPos;
	m_bySq = bySq;

	m_nDataLen = m_byLen + 4;
	m_pbyData = new byte[m_nDataLen];
	memset(m_pbyData, 0, m_nDataLen);
	*m_pbyData = m_bySq;
	*(m_pbyData+1) = m_byPos;
	*(m_pbyData+2) = m_byLen;
	memcpy(m_pbyData+3, m_pbyString, m_byLen);

	m_bDataChanged = FALSE;
}

// Class      : CharArray
// -------------------------------------------------------------------------
// Init CharArray
inline bool CharArray::Init(byte* pbyData)
{
	ClearData();
	if (pbyData == 0)
	{
		m_pbyData = NULL;
		m_nDataLen = 0;
		return FALSE;
	}
	m_bySq = *pbyData;
	m_byPos = *(pbyData+1);
	m_byLen = *(pbyData+2);
	m_pbyString = new byte[m_byLen+1];
	memset(m_pbyString, 0, m_byLen+1);
	memcpy(m_pbyString, pbyData+3, m_byLen);

	m_nDataLen = 4+m_byLen;
	m_pbyData = new byte[m_nDataLen];
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return (m_pbyData != 0);
}

// Class      : CharArray
// -------------------------------------------------------------------------
// Default Destructor
inline CharArray::~CharArray()
{
	ClearData();
}

// Class      : CharArray
// -------------------------------------------------------------------------
// ClearData
inline void CharArray::ClearData()
{
    if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}

	if (m_pbyString)
	{
		delete[] m_pbyString;
		m_pbyString = NULL;
	}
}

// Class      : CharArray
// -------------------------------------------------------------------------
// SetSq
inline void CharArray::SetSq(byte bySq)
{	
	m_bySq = bySq;
	m_bDataChanged = TRUE;
}

// Class      : CharArray
// -------------------------------------------------------------------------
// SetPos
inline void CharArray::SetPos(byte byPos)
{	
	m_byPos = byPos;
	m_bDataChanged = TRUE;
}

// Class      : CharArray
// -------------------------------------------------------------------------
// SetLen
inline void CharArray::SetLen(byte byLen)
{	
	m_byLen = byLen;
	m_nDataLen = m_byLen + 4;
	m_bDataChanged = TRUE;
}

// Class      : CharArray
// -------------------------------------------------------------------------
// SetString
inline void CharArray::SetString(byte* pbyString)
{	
	if (m_pbyString == NULL)
	{
		m_pbyString = new byte[m_byLen+1];
		memset(m_pbyString, 0, m_byLen+1);
	}

	memcpy(m_pbyString, pbyString, m_byLen);
	m_bDataChanged = TRUE;
}

// Class      : CharArray
// -------------------------------------------------------------------------
// GetData
inline byte* CharArray::GetData()
{
	ASSERT(m_byLen > 0);
	if (m_bDataChanged)
	{
		byte* pbyNewData;
		pbyNewData = new byte[m_nDataLen];
		memset(pbyNewData, 0, m_nDataLen);

		*pbyNewData = m_bySq;
		*(pbyNewData+1) = m_byPos;
		*(pbyNewData+2) = m_byLen;
		memcpy(pbyNewData+3, m_pbyString, m_byLen);
		if ( m_pbyData)
			delete [] m_pbyData;
		m_pbyData = pbyNewData;
		m_bDataChanged = FALSE;
		return m_pbyData;
	}
	else
	{
		if (!m_pbyData)
		{
			m_pbyData = new byte[m_nDataLen];

			*m_pbyData = m_bySq;
			*(m_pbyData+1) = m_byPos;
			*(m_pbyData+2) = m_byLen;
			return m_pbyData;
		}
	}

	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// LineContent structure
// A Structure to hold the Binary Data structure in MultiLine Object
//
struct Line
{
	byte		m_byLn;					// Line Number
	CharArray*	m_pCA;					// Data Type, user can cast it to different Binary Types
};


/////////////////////////////////////////////////////////////////////////////
//
// Class      : MCharArray
// Description: Multi Line data type and each line is a Char Array
//
class MCharArray : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	MCharArray():m_pLineArray(NULL),
				m_byNe(0),
				m_byTL(0) {m_nDataLen=2;}

	// -------------------------------------------------------------------------
	// Constructor - construct the MCharArray by data stream
	MCharArray(byte* pbyData):m_pLineArray(NULL),
				m_byNe(0),
				m_byTL(0) {Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
	virtual ~MCharArray();

// Operations
	// -------------------------------------------------------------------------
	// Get the total line
	byte GetTL()	{return m_byTL;}

	// -------------------------------------------------------------------------
	// Get the Number of Element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the Line Number by the index - start from 0, the valid return lin
	// should be > 0
	byte GetLn(short nIndex);

	// -------------------------------------------------------------------------
	// Get the Line Number by the index - start from 0
	CharArray* GetCA(short nIndex);

	// -------------------------------------------------------------------------
	// Set the total line
	void SetTL(byte byTL) { m_byTL = byTL; }

	// -------------------------------------------------------------------------
	// Add a line to the MCharArray
	bool AddLine(byte byLin, CharArray* pCA);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the MCharArray
	bool Init(byte* pbyData);

	static unsigned short GetByteLen(byte * pbyData);

private:
// Attributes
	byte		m_byTL;
	byte		m_byNe;
	Line*		m_pLineArray;

// Operator
	// -------------------------------------------------------------------------
	// Expand the buffer size if needed
	void ExpandBufferIfNeeded(short nLen);

protected:
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();
};

// Class      : MCharArray
// -------------------------------------------------------------------------
// Init MCharArray
inline bool MCharArray::Init(byte* pbyData)
{
	ClearData();
	if (pbyData == 0)
	{
		m_pbyData = NULL;
		m_nDataLen = 0;
		return FALSE;
	}

	m_nDataLen = 2;
	m_pbyData = pbyData;
	m_byTL = *m_pbyData;
	m_byNe = *(m_pbyData+1);
	m_pbyData+=2;

	Line* tmpLine = new Line;
	m_pLineArray = new Line[m_byNe+1];
	memset(m_pLineArray, 0, sizeof(Line)*(m_byNe+1));
	// Get the data length
	for (int i = 0 ; i < m_byNe; i++)
	{
		// Get the line element
		tmpLine->m_pCA = new CharArray;
		tmpLine->m_pCA->Init(m_pbyData+1);
		
		// Update the data length and the data pointer
		m_nDataLen = m_nDataLen + 1 + tmpLine->m_pCA->GetDataLen();
		m_pbyData = m_pbyData + 1 + tmpLine->m_pCA->GetDataLen();
		delete tmpLine->m_pCA;
	}
	// Parse the byte stream
	m_pbyData = new byte[m_nDataLen];
	memcpy(m_pbyData, pbyData, m_nDataLen);
	pbyData+=2;
	for (int i = 0 ; i < m_byNe; i++)
	{
		// Get the line element
		(m_pLineArray+i)->m_byLn = *pbyData;
		(m_pLineArray+i)->m_pCA = new CharArray;
		(m_pLineArray+i)->m_pCA->Init(pbyData+1);
		
		// Update the data length and the data pointer
		pbyData = pbyData + 1 + (m_pLineArray+i)->m_pCA->GetDataLen();
	}

	m_bDataChanged = FALSE;

	// delete the tmpLine
	delete tmpLine;
	return (m_pbyData != 0);
}

inline unsigned short MCharArray::GetByteLen(byte * pbyData) {
	byte * pointer = pbyData;

	byte ne = *(pointer + 1);
	pointer += 2;
	unsigned short size = 2;
	for (int i = 0; i < ne; i++)
	{
		// Get the line element
		unsigned short nCA = CharArray::GetByteLen(pointer + 1) + 1;
		size += nCA;
		pointer += nCA;
	}
	return size;
};

// Class      : MCharArray
// -------------------------------------------------------------------------
// Default Destructor
inline MCharArray::~MCharArray()
{
	ClearData();
}

// Class      : MCharArray
// -------------------------------------------------------------------------
// ClearData
inline void MCharArray::ClearData()
{
    if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}

	if (m_pLineArray)
	{
		for (int i = 0; i < m_byNe; i++)
		{
			delete (m_pLineArray+i)->m_pCA;
		}
		delete[] m_pLineArray;
		m_pLineArray = NULL;
	}
}

// Class      : MCharArray
// -------------------------------------------------------------------------
// Add Line
inline bool MCharArray::AddLine(byte byLin, CharArray* pCA)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
		m_pLineArray = new Line[256];
		memset(m_pLineArray, 0, 256);
	}
	else
		ExpandBufferIfNeeded(pCA->GetDataLen());

	// check whether it overflow the limit
	unsigned short nDataLen = pCA->GetDataLen();  // Changed by John
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	*(m_pbyData+m_nDataLen) = byLin;
	memcpy(m_pbyData+m_nDataLen+1, pCA->GetData(), nDataLen);

	// add the data to the line array
	(m_pLineArray+m_byNe)->m_byLn = byLin;
	(m_pLineArray+m_byNe)->m_pCA = new CharArray;
	(m_pLineArray+m_byNe)->m_pCA->Init(pCA->GetData());

	m_nDataLen = m_nDataLen + nDataLen + 1;
	m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : MCharArray
// -------------------------------------------------------------------------
// GetLin
inline byte MCharArray::GetLn(short nIndex)
{
	if (nIndex < m_byNe)
		return (m_pLineArray+nIndex)->m_byLn;
	else
		return 0;
}

// Class      : MCharArray
// -------------------------------------------------------------------------
// GetCA
inline CharArray* MCharArray::GetCA(short nIndex)
{
	if (nIndex < m_byNe)
		return (m_pLineArray+nIndex)->m_pCA;
	else
		return NULL;
}

// Class      : MCharArray
// -------------------------------------------------------------------------
// GetData
inline byte* MCharArray::GetData()
{
	ASSERT(m_byNe > 0);
	ASSERT(m_byTL > 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byTL;
	*(m_pbyData+1) = m_byNe;
	return m_pbyData;
}

// Class      : MCharArray
// -------------------------------------------------------------------------
// ExpandBufferIfNeeded
inline void MCharArray::ExpandBufferIfNeeded(short nLen)
{
	if (m_nDataLen + nLen >= m_nBufferSize && m_nBufferSize + 512 <USHRT_MAX)
	{
		byte* pbyNewBuffer = NULL;
		m_nBufferSize = m_nBufferSize + 512;
		pbyNewBuffer = new byte[m_nBufferSize];
		if (pbyNewBuffer) {
			memset(pbyNewBuffer, 0, m_nBufferSize);
			memcpy(pbyNewBuffer, m_pbyData, m_nBufferSize - 512);

			delete[] m_pbyData;
			m_pbyData = pbyNewBuffer;
		}
		else 
		{
			m_nBufferSize -= 512;
//			CApplManClient::Log(LOG_ERROR, "[MsgObject] MCA extend memeory failed");
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : BDateMonth
// Description: BDateMonth (Data Type D14)
//
class BDateMonth : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BDateMonth():m_byDD(1), m_byMM(1){	m_nDataLen = 2;}

	// -------------------------------------------------------------------------
	// Constructor - construct the date by input the date
	BDateMonth( byte byMM, byte byDD):m_byDD(byDD), m_byMM(byMM){ m_nDataLen = 2; }

	// -------------------------------------------------------------------------
	// Constructor - construct the date by byte stream
	BDateMonth(byte* pbyData):m_byDD(1), m_byMM(1){ Init(pbyData); }

	// -------------------------------------------------------------------------
	// Default Destructor
//	virtual ~BDateMonth();

// Operations
	// -------------------------------------------------------------------------
	// Get the Day
	byte GetDay()	{return m_byDD;}

	// -------------------------------------------------------------------------
	// Get the Month
	byte GetMonth()	{return m_byMM;}

	// -------------------------------------------------------------------------
	// Set the Day
	void SetDay(byte byDD)		{m_byDD = byDD;}

	// -------------------------------------------------------------------------
	// Set the Month
	void SetMonth(byte byMM)	{m_byMM = byMM;}

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the BDateMonth
	bool Init(byte* pbyData);

protected:
// Attributes
	byte	m_byDD;
	byte	m_byMM;
};

// Class      : BDateMonth
// -------------------------------------------------------------------------
// GetData
inline byte* BDateMonth::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];
	
	*m_pbyData = m_byMM;
	*(m_pbyData+1) = m_byDD;
	return m_pbyData;
}

// Class      : BDateMonth
// -------------------------------------------------------------------------
// Init
inline bool BDateMonth::Init(byte* pbyData)
{
	ClearData();
	m_pbyData = new byte[2];
	m_nDataLen =2;
	
	memcpy(m_pbyData, pbyData, 2);
	m_byMM = *m_pbyData;
	m_byDD = *(m_pbyData+1);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : BDateYear
// Description: BDateYear (Data Type D13)
//
class BDateYear : public BDateMonth
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BDateYear():m_nYY(2000){ m_nDataLen = 4;}

	// -------------------------------------------------------------------------
	// Constructor - construct the date by input the date
	BDateYear(short nYY, byte byMM, byte byDD):BDateMonth(byMM, byDD), m_nYY(nYY){ m_nDataLen = 4;}

	// -------------------------------------------------------------------------
	// Constructor - construct the date by byte stream
	BDateYear(byte* pbyData):m_nYY(2000)	{ Init(pbyData); }

// Operations
	// -------------------------------------------------------------------------
	// Get the Year
	short GetYear()	{return m_nYY;}

	// -------------------------------------------------------------------------
	// Set the Year
	void SetYear(short nYY)		{m_nYY = nYY;}

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the BDateYear
	bool Init(byte* pbyData);

private:
// Attributes
	short	m_nYY;
};

// Class      : BDateYear
// -------------------------------------------------------------------------
// GetData
inline byte* BDateYear::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];
	
	memcpy(m_pbyData, &m_nYY, 2);
	*(m_pbyData+2) = m_byMM;
	*(m_pbyData+3) = m_byDD;
	return m_pbyData;
}

// Class      : BDateMonth
// -------------------------------------------------------------------------
// Init
inline bool BDateYear::Init(byte* pbyData)
{
	ClearData();
	m_pbyData = new byte[4];
	m_nDataLen = 4;
	
	memcpy(m_pbyData, pbyData, 4);
	memcpy(&m_nYY, m_pbyData, 2);
	m_byMM = *(m_pbyData+2);
	m_byDD = *(m_pbyData+3);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : BTimeMin
// Description: BTimeMin (Data Type D15)
//
class BTimeMin : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BTimeMin():m_byHH(0), m_byMIN(0){ m_nDataLen = 2;}

	// -------------------------------------------------------------------------
	// Constructor - construct the date by input the date
	BTimeMin(byte byHH, byte byMIN):m_byHH(byHH), m_byMIN(byMIN){ m_nDataLen = 2;}

	// -------------------------------------------------------------------------
	// Constructor - construct the time by byte stream
	BTimeMin(byte* pbyData):m_byHH(0), m_byMIN(0){ Init(pbyData); }

// Operations
	// -------------------------------------------------------------------------
	// Get the Hour
	byte GetHH()	{return m_byHH;}

	// -------------------------------------------------------------------------
	// Get the Minute
	byte GetMIN()	{return m_byMIN;}

	// -------------------------------------------------------------------------
	// Set the Hour
	void SetHH(byte byHH)		{m_byHH = byHH;}

	// -------------------------------------------------------------------------
	// Set the Minute
	void SetMIN(byte byMIN)	{m_byMIN = byMIN;}

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the BTimeMin
	bool Init(byte* pbyData);

protected:
// Attributes
	byte	m_byHH;
	byte	m_byMIN;
};

// Class      : BTimeMin
// -------------------------------------------------------------------------
// GetData
inline byte* BTimeMin::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byHH;
	*(m_pbyData+1) = m_byMIN;
	return m_pbyData;
}

// Class      : BTimeMin
// -------------------------------------------------------------------------
// Init
inline bool BTimeMin::Init(byte* pbyData)
{
	ClearData();
	m_pbyData = new byte[2];
	m_nDataLen = 2;
	
	memcpy(m_pbyData, pbyData, 2);
	m_byHH = *m_pbyData;
	m_byMIN = *(m_pbyData+1);
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : BTimeSec
// Description: BTimeSec (Data Type D16)
//
class BTimeSec : public BTimeMin
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BTimeSec():BTimeMin(), m_bySS(0){ m_nDataLen = 3;}

	// -------------------------------------------------------------------------
	// Constructor - construct the date by input the date
	BTimeSec(byte byHH, byte byMIN, byte bySS):BTimeMin(byHH, byMIN), m_bySS(bySS){ m_nDataLen = 3;}

	// -------------------------------------------------------------------------
	// Constructor - construct the time by byte stream
	BTimeSec(byte* pbyData):BTimeMin(), m_bySS(0){ Init(pbyData); }

// Operations
	// -------------------------------------------------------------------------
	// Get the Hour
	byte GetSS()	{return m_bySS;}

	// -------------------------------------------------------------------------
	// Set the Hour
	void SetSS(byte bySS)		{m_bySS = bySS;}

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the BTimeSec
	bool Init(byte* pbyData);

private:
// Attributes
	byte	m_bySS;
};

// Class      : BTimeSec
// -------------------------------------------------------------------------
// GetData
inline byte* BTimeSec::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byHH;
	*(m_pbyData+1) = m_byMIN;
	*(m_pbyData+2) = m_bySS;
	return m_pbyData;
}

// Class      : BTimeSec
// -------------------------------------------------------------------------
// Init
inline bool BTimeSec::Init(byte* pbyData)
{
	ClearData();
	m_pbyData = new byte[3];
	m_nDataLen = 3;
	
	memcpy(m_pbyData, pbyData, 3);
	m_byHH = *m_pbyData;
	m_byMIN = *(m_pbyData+1);
	m_bySS = *(m_pbyData+2);
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : BTimeRanges
// Description: BTimeRanges (Data Type D17)
//
class BTimeRanges : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BTimeRanges():	m_byNe(0){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor - construct the time by byte stream
	BTimeRanges(byte* pbyData):	m_byNe(0){ Init(pbyData); }

// Operations
	// -------------------------------------------------------------------------
	// Get the Range - index start from 0
	bool GetRange(short nIndex, BTimeMin &S_Time, BTimeMin &E_Time);

	// -------------------------------------------------------------------------
	// Get NE
	byte GetNe(){return m_byNe;}

	// -------------------------------------------------------------------------
	// Add a time Range
	bool AddRange(BTimeMin S_Time, BTimeMin E_Time);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the BTimeRanges
	bool Init(byte* pbyData);

private:
// Attributes
	byte	m_byNe;
};

// Class      : BTimeRanges
// -------------------------------------------------------------------------
// Init
inline bool BTimeRanges::Init(byte* pbyData)
{
	ClearData();

	m_byNe = *pbyData;
	m_nDataLen = m_byNe*4+1;
	m_pbyData = new byte[m_nDataLen];
	memset(m_pbyData, 0, m_nDataLen);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : BTimeRanges
// -------------------------------------------------------------------------
// GetRange - index start from 0
inline bool BTimeRanges::GetRange(short nIndex, BTimeMin &S_Time, BTimeMin &E_Time)
{
	if (nIndex > m_byNe)
		return FALSE;

	S_Time.Init(m_pbyData+nIndex*4+1);
	E_Time.Init(m_pbyData+nIndex*4+3);
	return TRUE;
}

// Class      : BTimeRanges
// -------------------------------------------------------------------------
// Init
inline bool BTimeRanges::AddRange(BTimeMin S_Time, BTimeMin E_Time)
{
	if (!m_bDataChanged)
		return FALSE;

	if (!m_pbyData)
	{
		m_nBufferSize = 256;
		m_pbyData = new byte[m_nBufferSize*4+1];
		memset(m_pbyData, 0, m_nBufferSize*4+1);
	}

	if (m_byNe+1>m_nBufferSize)
		return FALSE;

	memcpy((m_pbyData+1+m_byNe*4), S_Time.GetData(), 2);
	memcpy((m_pbyData+1+m_byNe*4+2), E_Time.GetData(), 2);
	m_byNe++;
	m_nDataLen+=4;
	*m_pbyData = m_byNe;
	return TRUE;
}

// Class      : BTimeRanges
// -------------------------------------------------------------------------
// GetData
inline byte* BTimeRanges::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : Tran
// Description: Data Type D18
//
class Tran : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	Tran();

	// -------------------------------------------------------------------------
	// Constructor - construct the Tran by data stream
	Tran(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the Number of Element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth element of the array
	bool GetTranElement(short nIndex, unsigned long &ulSq,
						BTimeMin &Tm,
						double &dVl,
						float &fNm,
						byte &byFg);

	// -------------------------------------------------------------------------
	// Add an element to the Tran
	bool AddTranElement(unsigned long ulSq, 
						BTimeMin Tm,
						double dVl,
						float fNm,
						byte byFg);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the Tran
	bool Init(byte* pbyData);

private:
// Attributes
	byte			m_byNe;
};

// Class      : Tran
// -------------------------------------------------------------------------
// Default constructor
inline Tran::Tran()
{
	m_nDataLen = 1;
	m_nBufferSize = 382;
	m_byNe = 0;
}

// Class      : Tran
// -------------------------------------------------------------------------
// Init Tran
inline bool Tran::Init(byte* pbyData)
{
	ClearData();
	if (pbyData == 0) 
		return FALSE;

	m_byNe = *pbyData;

	m_nDataLen = 1+m_byNe*19;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);

	m_byNe = *m_pbyData;
	m_bDataChanged = FALSE;
	return (m_pbyData != 0);
}

// Class      : Tran
// -------------------------------------------------------------------------
// AddTranElement
inline bool Tran::AddTranElement(unsigned long ulSq, 
						BTimeMin Tm,
						double dVl,
						float fNm,
						byte byFg)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 20)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &ulSq, 4);
	if (Tm.GetData())
		memcpy(m_pbyData+m_nDataLen+4, Tm.GetData(), 2);
	memcpy(m_pbyData+m_nDataLen+6, &dVl, 8);
	memcpy(m_pbyData+m_nDataLen+14, &fNm, 4);
	memcpy(m_pbyData+m_nDataLen+18, &byFg, 1);

	m_nDataLen = m_nDataLen + 19;
	m_byNe = m_byNe + 1;
	return TRUE;
}


// Class      : Tran
// -------------------------------------------------------------------------
// GetTranElement - start from 0
inline bool Tran::GetTranElement(short nIndex, unsigned long &ulSq,
						BTimeMin &Tm,
						double &dVl,
						float &fNm,
						byte &byFg)
{
	if (nIndex < m_byNe)
	{
		memcpy(&ulSq, (m_pbyData+1+19*nIndex), 4);
		Tm.Init((m_pbyData+5+19*nIndex));
		memcpy(&dVl, (m_pbyData+7+19*nIndex), 8);
		memcpy(&fNm, (m_pbyData+15+19*nIndex), 4);
		memcpy(&byFg, (m_pbyData+19+19*nIndex), 1);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : Tran
// -------------------------------------------------------------------------
// GetData
inline byte* Tran::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : Txn
// Description: Data Type D19
//
class Txn : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	Txn();

	// -------------------------------------------------------------------------
	// Constructor - construct the Txn by data stream
	Txn(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the total line
	unsigned long GetTL()	{return m_ulTL;}

	// -------------------------------------------------------------------------
	// Get the Number of Element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the Sequence Number
	unsigned long GetSq()	{return m_ulSq;}

	// -------------------------------------------------------------------------
	// Get the nth element of the array
	bool GetTranElement(short nIndex, 
						BTimeMin &Tm,
						double &dVl,
						float &fNm,
						byte &byFg);

	// -------------------------------------------------------------------------
	// Set the total line
	void SetTL(unsigned long ulTL) { m_ulTL = ulTL; }

	// -------------------------------------------------------------------------
	// Set the Sequence number
	void SetSq(unsigned long ulSq) { m_ulSq = ulSq; }

	// -------------------------------------------------------------------------
	// Add an element to the Txn
	bool AddTranElement(BTimeMin Tm,
						double dVl,
						float fNm,
						byte byFg);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the Txn
	bool Init(byte* pbyData);

private:
// Attributes
	unsigned long	m_ulTL;
	byte			m_byNe;
	unsigned long	m_ulSq;
};

// Class      : Txn
// -------------------------------------------------------------------------
// Default constructor
inline Txn::Txn()
{
	m_nDataLen = 9;
	m_nBufferSize = 310;
	m_ulTL = 0;
	m_byNe = 0;
	m_ulSq = 0;
}

// Class      : Txn
// -------------------------------------------------------------------------
// Init Txn
inline bool Txn::Init(byte* pbyData)
{
	ClearData();
	if (pbyData == 0) 
		return FALSE;

	memcpy(&m_ulTL, pbyData, 4);
	m_byNe = *(pbyData+4);
	memcpy(&m_ulSq, pbyData+5, 4);

	m_nDataLen = 9+m_byNe*15;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return (m_pbyData != 0);
}

// Class      : Txn
// -------------------------------------------------------------------------
// AddTranElement
inline bool Txn::AddTranElement(BTimeMin Tm,
						double dVl,
						float fNm,
						byte byFg)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 20)
		return FALSE;

	// add the data to the buffer stream
	if (Tm.GetData())
		memcpy(m_pbyData+m_nDataLen, Tm.GetData(), 2);
	memcpy(m_pbyData+m_nDataLen+2, &dVl, 8);
	memcpy(m_pbyData+m_nDataLen+10, &fNm, 4);
	memcpy(m_pbyData+m_nDataLen+14, &byFg, 1);

	m_nDataLen = m_nDataLen + 15;
	m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : Txn
// -------------------------------------------------------------------------
// GetTranElement - start from 0
inline bool Txn::GetTranElement(short nIndex, 
						BTimeMin &Tm,
						double &dVl,
						float &fNm,
						byte &byFg)
{
	if (nIndex < m_byNe)
	{
		Tm.Init((m_pbyData+9+15*nIndex));
		memcpy(&dVl, (m_pbyData+11+15*nIndex), 8);
		memcpy(&fNm, (m_pbyData+19+15*nIndex), 4);
		memcpy(&byFg, (m_pbyData+23+15*nIndex), 1);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : Txn
// -------------------------------------------------------------------------
// GetData
inline byte* Txn::GetData()
{
	ASSERT(m_ulTL >= m_byNe + m_ulSq);
	ASSERT(m_ulTL > 0);
	ASSERT(m_byNe > 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	memcpy(m_pbyData, &m_ulTL, 4);
	*(m_pbyData+4) = m_byNe;
	memcpy(m_pbyData+5, &m_ulSq, 4);
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : ShrOrdLst
// Description: ShrOrdLst (Data Type D20)
//
class ShrOrdLst : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	ShrOrdLst():datatype(), m_pcSh(NULL), m_ulSh(0), m_unOr(0), m_dSh(0), m_unSh(0), m_byUnit(0), m_byDecimal(0){m_nDataLen = 4;}

	// -------------------------------------------------------------------------
	// Constructor - by byte stream
	ShrOrdLst(byte* pbyData):datatype(), m_pcSh(NULL), m_ulSh(0), m_unOr(0), m_dSh(0), m_unSh(0), m_byUnit(0), m_byDecimal(0)	{Init(pbyData);}

	// -------------------------------------------------------------------------
	// Destructor
	~ShrOrdLst();

// Operations
	// -------------------------------------------------------------------------
	// Get shares number by String
	const char* GetShStr()	{
		if (m_pcSh == nullptr){
			unsigned long ulSh = (unsigned long)(m_unSh*pow((double)1000, m_byUnit) / pow((double)10, m_byDecimal));
			SetSh(ulSh);
		}		
		return m_pcSh;}

	// -------------------------------------------------------------------------
	// Get shares number by double
	unsigned long GetSh()	{return m_ulSh;}

	// -------------------------------------------------------------------------
	// Get the orders of share
	short GetOr()	{return m_unOr;}

	// -------------------------------------------------------------------------
	// Set shares number
	void SetSh(unsigned long ulSh);

	// -------------------------------------------------------------------------
	// Set the orders of share
	void SetOr(unsigned short unOr)	{m_unOr = unOr;}

	// -------------------------------------------------------------------------
	// Init the ShrOrdLst
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get Data
	byte* GetData();

private:
// Attributes
//	byte			m_byIN;
	char*			m_pcSh;
	unsigned long	m_ulSh;
	unsigned short	m_unOr;

	double			m_dSh;
	unsigned short	m_unSh;
	byte			m_byUnit;		// the Unit
	byte			m_byDecimal;	// decimal point

// operation
	void	Calculate(unsigned long &ulSh, unsigned long &nRemainder, byte &byUnit);

	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();
};

// Class      : ShrOrdLst
// -------------------------------------------------------------------------
// SetItemNo
inline ShrOrdLst::~ShrOrdLst()
{
	ClearData();
}

// Class      : ShrOrdLst
// -------------------------------------------------------------------------
// ClearData
inline void ShrOrdLst::ClearData()
{
    if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}

	if (m_pcSh)
	{
		delete[] m_pcSh;
		m_pcSh = NULL;
	}
}

// Class      : ShrOrdLst
// -------------------------------------------------------------------------
// SetItemNo
inline void ShrOrdLst::SetSh(unsigned long ulSh)
{
	m_ulSh = ulSh;
	m_byUnit = 0;
	m_byDecimal = 0;
	if (!m_pcSh)
	{
		m_pcSh = new char[7];
	}
	memset(m_pcSh, 0, 7);

	unsigned long nRem=0;
	if (m_ulSh < 10000)
		sprintf_s(m_pcSh,7, "%d", m_ulSh);
	else
	{
		// calculate the quotion and the remainder recursively
		Calculate(m_ulSh, nRem, m_byUnit);
		// guard the case that the number is larger than 999B
		if (m_byUnit > 3)
		{
			m_byUnit = 3;
			strncpy_s(m_pcSh,7, "999B", 4);
			m_byDecimal = 0;
			return;
		}

		// format the Share string
		m_dSh = m_ulSh + nRem * 0.001 + 0.0000000000001;
		//sprintf(m_pcSh, "%.4g", m_dSh);

		int size = sizeof(m_pcSh); 
		sprintf_s(m_pcSh,7, "%.3g", m_dSh);
	}

	if (strchr(m_pcSh, '.')) 
	{
		m_byDecimal = 5 - (strchr(m_pcSh, '.')-m_pcSh+1);
		if (m_byDecimal == 0)
			memset(m_pcSh+3, 0, 1);
	}
	if(nRem>=500&&m_byDecimal==0)
		m_ulSh++;
	m_unSh = (unsigned short)( m_ulSh * pow((double)10, m_byDecimal) + nRem / pow((double)10, (3-m_byDecimal)));

	ASSERT(strlen(m_pcSh) < 6);

	int end = strlen(m_pcSh);
	switch (m_byUnit)
	{
		case 1:
			*(m_pcSh+end) = 'K';
			break;
		case 2:
			*(m_pcSh+end) = 'M';
			break;
		case 3:
			*(m_pcSh+end) = 'B';
			break;
		default:
			break;
	}
	*(m_pcSh + end+1) = '\0';

}

// Class      : ShrOrdLst
// -------------------------------------------------------------------------
// SetItemNo
inline void ShrOrdLst::Calculate(unsigned long &ulSh, unsigned long &nRemainder, byte &byUnit)
{
	if (ulSh >= 1000)
	{
		nRemainder = ulSh % 1000;
		ulSh = ulSh / 1000;
		byUnit++;
		Calculate(ulSh, nRemainder, byUnit);
	}
}

// Class      : ShrOrdLst
// -------------------------------------------------------------------------
// Init
inline bool ShrOrdLst::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	if (!m_pbyData)
	{
		m_nDataLen = 4;
		m_pbyData = new byte[m_nDataLen];
		memset(m_pbyData, 0, 4);
	}
	memcpy(m_pbyData, pbyData, 4);

	memcpy(&m_unSh, m_pbyData, 2);
	m_byUnit = (byte) ((m_unSh & 0xC000) >> 14);
	m_unSh = m_unSh & 0x3FFF;

	memcpy(&m_unOr, m_pbyData+2, 2);
	m_byDecimal = (byte)((m_unOr & 0xC000) >> 14);
	m_unOr = m_unOr & 0x3FFF;

	//unsigned long ulSh = (unsigned long) (m_unSh*pow((double)1000, m_byUnit)/pow((double)10, m_byDecimal));
	//SetSh(ulSh);
	return TRUE;
}

// Class      : ShrOrdLst
// -------------------------------------------------------------------------
// GetData
inline byte* ShrOrdLst::GetData()
{
	if (!m_pbyData)
	{
		m_pbyData = new byte[m_nDataLen];
		memset(m_pbyData, 0, 4);
	}
	unsigned short unB12 = ((unsigned short) m_byUnit << 14) | (m_unSh & 0x3FFF);
	memcpy(m_pbyData, &unB12, 2);

	unsigned short unB34 = ((unsigned short) m_byDecimal << 14) | (m_unOr & 0x3FFF);
	memcpy(m_pbyData+2, &unB34, 2);
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : YLabel
// Description: YLabel (Data Type D25)
//
class YLabel : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	YLabel(){Init(NULL);}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	YLabel(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the High
	float GetHigh()	{return m_fHigh;}

	// -------------------------------------------------------------------------
	// Get the Mid
	float GetMid()	{return m_fMid;}

	// -------------------------------------------------------------------------
	// Get the Low
	float GetLow()	{return m_fLow;}

	// -------------------------------------------------------------------------
	// Set the High
	void SetHigh(float fHigh);

	// -------------------------------------------------------------------------
	// Set the Mid
	void SetMid(float fMid);

	// -------------------------------------------------------------------------
	// Set the Low
	void SetLow(float fLow);

	// -------------------------------------------------------------------------
	// Init the YLabel
	bool Init(byte* pbyData);

private:
// Attributes
	float		m_fHigh;
	float		m_fMid;
	float		m_fLow;
};

// Class      : YLabel
// -------------------------------------------------------------------------
// Init
inline bool YLabel::Init(byte* pbyData)
{
	ClearData();
	m_nDataLen = 12;
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	if (pbyData)
	{
		memcpy(m_pbyData, pbyData, m_nDataLen);
		memcpy(&m_fHigh, m_pbyData, 4);
		memcpy(&m_fMid, (m_pbyData + 4), 4);
		memcpy(&m_fLow, (m_pbyData + 8), 4);
	}
	return TRUE;
}

// Class      : YLabel
// -------------------------------------------------------------------------
// SetHigh
inline void YLabel::SetHigh(float fHigh)
{
	m_fHigh = fHigh;
	memcpy(m_pbyData, &m_fHigh, 4);
}

// Class      : YLabel
// -------------------------------------------------------------------------
// SetHigh
inline void YLabel::SetMid(float fMid)
{
	m_fMid = fMid;
	memcpy(m_pbyData+4, &m_fMid, 4);
}

// Class      : YLabel
// -------------------------------------------------------------------------
// SetHigh
inline void YLabel::SetLow(float fLow)
{
	m_fLow = fLow;
	memcpy(m_pbyData+8, &m_fLow, 4);
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : XMtcLabel
// Description: XMtcLabel (Data Type D26)
//
class XMtcLabel : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	XMtcLabel():m_byNe(0){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	XMtcLabel(byte* pbyData):m_byNe(0){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth Time
	bool GetTime(short nIndex, unsigned short &unPos, BTimeMin &tm);
	
	// -------------------------------------------------------------------------
	// add the XMtcLabel to the array
	bool AddTime(unsigned short unPos, BTimeMin tm);

	// -------------------------------------------------------------------------
	// Init the XMtcLabel
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// GetData
	byte* GetData();

private:
// Attributes
	byte m_byNe;
};

// Class      : XMtcLabel
// -------------------------------------------------------------------------
// GetTime - start from 0
inline bool XMtcLabel::GetTime(short nIndex, unsigned short &unPos, BTimeMin &tm)
{
	if (nIndex < m_byNe)
	{
		memcpy(&unPos, (m_pbyData+1+4*nIndex), 2);
		tm.Init((m_pbyData+3+4*nIndex));
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : XMtcLabel
// -------------------------------------------------------------------------
// AddUFloat
inline bool XMtcLabel::AddTime(unsigned short unPos, BTimeMin tm)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &unPos, 2);
	memcpy(m_pbyData+m_nDataLen+2, tm.GetData(), 2);

	m_nDataLen = m_nDataLen + 4;
	*(m_pbyData) = m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : XMtcLabel
// -------------------------------------------------------------------------
// Init
inline bool XMtcLabel::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	m_nDataLen = m_byNe*4+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : XMtcLabel
// -------------------------------------------------------------------------
// GetData
inline byte* XMtcLabel::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : XDtcLabel
// Description: XDtcLabel (Data Type D27)
//
class XDtcLabel : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	XDtcLabel():m_byNe(0){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	XDtcLabel(byte* pbyData):m_byNe(0){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth Date
	bool GetDate(short nIndex, unsigned short &unPos, BDateMonth &dm);
	
	// -------------------------------------------------------------------------
	// add the XDtcLabel to the array
	bool AddDate(unsigned short unPos, BDateMonth dm);

	// -------------------------------------------------------------------------
	// Init the XDtcLabel
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// GetData
	byte* GetData();

private:
// Attributes
	byte m_byNe;
};

// Class      : XDtcLabel
// -------------------------------------------------------------------------
// GetDate - start from 0
inline bool XDtcLabel::GetDate(short nIndex, unsigned short &unPos, BDateMonth &dm)
{
	if (nIndex < m_byNe)
	{
		memcpy(&unPos, (m_pbyData+1+4*nIndex), 2);
		dm.Init((m_pbyData+3+4*nIndex));
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : XDtcLabel
// -------------------------------------------------------------------------
// AddDate
inline bool XDtcLabel::AddDate(unsigned short unPos, BDateMonth dm)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &unPos, 2);
	memcpy(m_pbyData+m_nDataLen+2, dm.GetData(), 2);

	m_nDataLen = m_nDataLen + 4;
	*(m_pbyData) = m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : XDtcLabel
// -------------------------------------------------------------------------
// Init
inline bool XDtcLabel::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	m_nDataLen = m_byNe*4+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : XDtcLabel
// -------------------------------------------------------------------------
// GetData
inline byte* XDtcLabel::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : BkrQue
// Description: BkrQue (Data Type D22)
//
class BkrQue : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BkrQue():m_byNe(0), m_pnPosArray(NULL){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor by byte Stream
	BkrQue(byte* pbyData):m_byNe(0), m_pnPosArray(NULL){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Constructor by byte Stream
	~BkrQue();

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth A
	bool GetBroker(short nIndex, byte &byA, unsigned short &unB, unsigned short &unC);

	// -------------------------------------------------------------------------
	// Add Broker to the array
	bool AddBroker(byte byA, unsigned short unB, unsigned short unC);

	// -------------------------------------------------------------------------
	// Init the BkrQue
	bool Init(byte* pbyData);

	static unsigned short GetByteLength(byte * pbyData);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

private:
// Attributes
	byte	m_byNe;
	short	*m_pnPosArray;

protected:
// Operation
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();
};

// Class      : BkrQue
// -------------------------------------------------------------------------
// Destructor
inline BkrQue::~BkrQue()
{
	ClearData();
}

// Class      : BkrQue
// -------------------------------------------------------------------------
// ClearData
inline void BkrQue::ClearData()
{
	if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}
	if (m_pnPosArray)
	{
		delete[] m_pnPosArray;
		m_pnPosArray = NULL;
	}
}

// Class      : BkrQue
// -------------------------------------------------------------------------
// GetBroker - start from 0
inline bool BkrQue::GetBroker(short nIndex, byte &byA, unsigned short &unB, unsigned short &unC)
{
	if (nIndex < m_byNe)
	{
		memcpy(&unB, (m_pbyData+*(m_pnPosArray+nIndex)), 2);
		byA = (byte) ((unB & 0xC000) >> 14);
		unB = unB & 0x3FFF;
		unC = 0;
		if (byA==3)
		{
			memcpy(&unC, (m_pbyData+*(m_pnPosArray+nIndex)+2), 2);
		}
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : BkrQue
// -------------------------------------------------------------------------
// AddUFloat
inline bool BkrQue::AddBroker(byte byA, unsigned short unB, unsigned short unC)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
		m_pnPosArray = new short[256];
		memset(m_pnPosArray, 0, 256);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	if (byA == 3)
	{
		if (m_nDataLen + 4>=1024)
			return FALSE;
	}
	else
	{
		if (m_nDataLen + 2>=1024)
			return FALSE;
	}

	// add the data to the buffer stream
	unsigned short unAB = byA;
	unAB = (unAB<<14) | unB;

	memcpy(m_pbyData+m_nDataLen, &unAB, 2);
	if (byA == 3)
	{
		memcpy(m_pbyData+m_nDataLen+2, &unC, 2);
		m_nDataLen = m_nDataLen + 4;
	}
	else
		m_nDataLen = m_nDataLen + 2;

	*(m_pbyData) = m_byNe = m_byNe + 1;
	*(m_pnPosArray+m_byNe) = m_nDataLen;
	return TRUE;
}

// Class      : BkrQue
// -------------------------------------------------------------------------
// Init
inline bool BkrQue::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	if (!m_pnPosArray)
	{
		m_pnPosArray = new short[m_byNe];
		memset(m_pnPosArray, 0, 2*m_byNe);
	}
	byte byA = 0;
	m_nDataLen = 1;
	for (int i=0; i<m_byNe; i++)
	{
		*(m_pnPosArray+i) = m_nDataLen;
		byA = (byte) ((*((short*)(pbyData+m_nDataLen)) & 0xC000) >> 14);
		if (byA == 3)
			m_nDataLen = m_nDataLen+4;
		else
			m_nDataLen = m_nDataLen+2;
	}
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short BkrQue::GetByteLength(byte* pbyData)
{
	unsigned short size = 1;
	byte ne = *pbyData;

	for (int i = 0; i < ne; i++){
		byte byA = (byte)((*((short*)(pbyData + size)) & 0xC000) >> 14);
		size +=  byA == 3 ? 4 : 2;
	}
	return size;
}

// Class      : BkrQue
// -------------------------------------------------------------------------
// GetData
inline byte* BkrQue::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];
	
	*(m_pbyData) = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : Base
// Description: Base Class for D21, D23, D24, D28, D29, D31
//
class Base : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	Base():m_unTL(0), m_unNe(0), m_unPos(0){m_nDataLen = 6;}

	// -------------------------------------------------------------------------
	// Constructor - construct the Base by data stream
	Base(byte* pbyData):m_unTL(0), m_unNe(0), m_unPos(0){Init(pbyData);}

// Operations
	// ******************Get********************
	// -------------------------------------------------------------------------
	// Get the Total number of Vals
	unsigned short GetTL()	{return m_unTL;}

	// -------------------------------------------------------------------------
	// Get the number of element
	unsigned short GetNe()	{return m_unNe;}

	// -------------------------------------------------------------------------
	// Get the position
	unsigned short GetPos()	{return m_unPos;}
	
	// ******************Set********************
	// -------------------------------------------------------------------------
	// Set the Total number of Vals
	void SetTL(unsigned short unTL)	{m_unTL = unTL;}

	// -------------------------------------------------------------------------
	// Set the number of postition
	void SetPos(unsigned short unPos)	{m_unPos = unPos;}

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the Base
//	bool Init(byte* pbyData);

protected:
// Attributes
	unsigned short	m_unTL;
	unsigned short	m_unNe;
	unsigned short	m_unPos;
};

// Class      : Base
// -------------------------------------------------------------------------
// GetData
inline byte* Base::GetData()
{
	ASSERT(m_unTL >= m_unNe + m_unPos && m_unNe >= 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];
	
	memcpy(m_pbyData, &m_unTL, 2);
	memcpy(m_pbyData+2, &m_unNe, 2);
	memcpy((m_pbyData+4), &m_unPos, 2);
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : PrcVol
// Description: PrcVol (Data Type D21)
//
class PrcVol: public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	PrcVol():m_byTL(0), m_byNe(0), m_byPos(0){m_nDataLen = 3;}

	// -------------------------------------------------------------------------
	// Constructor - construct the PrcVol by data stream
	PrcVol(byte* pbyData):m_byTL(0), m_byNe(0), m_byPos(0){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the Total number of Vals
	unsigned short GetTL()	{return m_byTL;}

	// -------------------------------------------------------------------------
	// Get the number of element
	unsigned short GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the position
	unsigned short GetPos()	{return m_byPos;}
	
	// -------------------------------------------------------------------------
	// Set the Total number of Vals
	void SetTL(byte byTL)	{m_byTL = byTL;}

	// -------------------------------------------------------------------------
	// Set the number of postition
	void SetPos(byte byPos)	{m_byPos = byPos;}

	// -------------------------------------------------------------------------
	// Get the nth PrcVol
	bool GetPrcVol(short nIndex, float &fPr, double &dVl);

	// -------------------------------------------------------------------------
	// add the PrcVol to the array
	bool AddPrcVol(float fPr, double dVl);

	// -------------------------------------------------------------------------
	// Init the PrcVol
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the data
	byte* GetData();

private:
	byte m_byTL;
	byte m_byNe;
	byte m_byPos;
};

// Class      : PrcVol
// -------------------------------------------------------------------------
// GetPrcVol - start from 0
inline bool PrcVol::GetPrcVol(short nIndex, float &fPr, double &dVl)
{
	if (nIndex < m_byNe)
	{
		memcpy(&fPr, (m_pbyData+3+12*nIndex), 4);
		memcpy(&dVl, (m_pbyData+7+12*nIndex), 8);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : PrcVol
// -------------------------------------------------------------------------
// AddPrcVol
inline bool PrcVol::AddPrcVol(float fPr, double dVl)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 244;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 20)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &fPr, 4);
	memcpy(m_pbyData+m_nDataLen+4, &dVl, 8);

	m_nDataLen = m_nDataLen + 12;
	m_byNe = m_byNe + 1;
	memcpy(m_pbyData+1, &m_byNe, 1);
	return TRUE;
}

// Class      : PrcVol
// -------------------------------------------------------------------------
// Init
inline bool PrcVol::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	memcpy(&m_byTL, pbyData, 1);
	memcpy(&m_byNe, pbyData+1, 1);
	memcpy(&m_byPos, (pbyData+2), 1);
	m_nDataLen = m_byNe*12+3;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : PrcVol
// -------------------------------------------------------------------------
// GetData
inline byte* PrcVol::GetData()
{
	ASSERT(m_byTL >= m_byNe + m_byPos && m_byNe >= 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	memcpy(m_pbyData, &m_byTL, 1);
	memcpy(m_pbyData+1, &m_byNe, 1);
	memcpy((m_pbyData+2), &m_byPos, 1);
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : PrcVolwSeq
// Description: PrcVolwSeq (Data Type D50)
//
class PrcVolwSeq: public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	PrcVolwSeq():m_byTL(0), m_byNe(0), m_byPos(0), m_ulSq(0){m_nDataLen = 7;}

	// -------------------------------------------------------------------------
	// Constructor - construct the PrcVol by data stream
	PrcVolwSeq(byte* pbyData):m_byTL(0), m_byNe(0), m_byPos(0), m_ulSq(0){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the Total number of Vals
	unsigned short GetTL()	{return m_byTL;}

	// -------------------------------------------------------------------------
	// Get the number of element
	unsigned short GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the position
	unsigned short GetPos()	{return m_byPos;}
	
    // -------------------------------------------------------------------------
	// Get the Sequence Number
	unsigned long GetSq()	{return m_ulSq;}

	// -------------------------------------------------------------------------
	// Set the Total number of Vals
	void SetTL(byte byTL)	{m_byTL = byTL;}

	// -------------------------------------------------------------------------
	// Set the number of postition
	void SetPos(byte byPos)	{m_byPos = byPos;}

    // -------------------------------------------------------------------------
	// Set the Sequence number
	void SetSq(unsigned long ulSq) { m_ulSq = ulSq; }

	// -------------------------------------------------------------------------
	// Get the nth PrcVol
	bool GetPrcVol(short nIndex, float &fPr, double &dVl);

	// -------------------------------------------------------------------------
	// add the PrcVol to the array
	bool AddPrcVol(float fPr, double dVl);

	// -------------------------------------------------------------------------
	// Init the PrcVol
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the data
	byte* GetData();

private:
	byte m_byTL;
	byte m_byNe;
	byte m_byPos;
    unsigned long	m_ulSq;
};

// Class      : PrcVolwSeq
// -------------------------------------------------------------------------
// GetPrcVol - start from 0
inline bool PrcVolwSeq::GetPrcVol(short nIndex, float &fPr, double &dVl)
{
	if (nIndex < m_byNe)
	{
		memcpy(&fPr, (m_pbyData+7+12*nIndex), 4);
		memcpy(&dVl, (m_pbyData+11+12*nIndex), 8);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : PrcVolwSeq
// -------------------------------------------------------------------------
// AddPrcVol
inline bool PrcVolwSeq::AddPrcVol(float fPr, double dVl)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 12*100 + 7;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	    if (m_byNe + 1 > 100)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &fPr, 4);
	memcpy(m_pbyData+m_nDataLen+4, &dVl, 8);

	m_nDataLen = m_nDataLen + 12;
	m_byNe = m_byNe + 1;
	memcpy(m_pbyData+1, &m_byNe, 1);
	return TRUE;
}

// Class      : PrcVolwSeq
// -------------------------------------------------------------------------
// Init
inline bool PrcVolwSeq::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	memcpy(&m_byTL, pbyData, 1);
	memcpy(&m_byNe, pbyData+1, 1);
	memcpy(&m_byPos, (pbyData+2), 1);
    memcpy(&m_ulSq, (pbyData+3), 4);
	//m_nDataLen = m_byNe*12+3;
    m_nDataLen = m_byNe*12+7;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : PrcVolwSeq
// -------------------------------------------------------------------------
// GetData
inline byte* PrcVolwSeq::GetData()
{
	ASSERT(m_byTL >= m_byNe + m_byPos && m_byNe >= 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	memcpy(m_pbyData, &m_byTL, 1);
	memcpy(m_pbyData+1, &m_byNe, 1);
	memcpy((m_pbyData+2), &m_byPos, 1);
    memcpy((m_pbyData+3), &m_ulSq, 4);
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : Link
// Description: Link (Data Type D23)
//
class Link : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	Link(){};

	// -------------------------------------------------------------------------
	// Constructor - construct the Link by data stream
	Link(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the nth Link
	bool GetLink(short nIndex, unsigned long &ulPg);

	// -------------------------------------------------------------------------
	// add the link to the array
	bool AddLink(unsigned long ulPg);

	// -------------------------------------------------------------------------
	// Init the Link
	bool Init(byte* pbyData);
};

// Class      : Link
// -------------------------------------------------------------------------
// GetLink - start from 0
inline bool Link::GetLink(short nIndex, unsigned long &ulPg)
{
	if (nIndex < m_unNe)
	{
		memcpy(&ulPg, (m_pbyData+6+nIndex*4), 4);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : Link
// -------------------------------------------------------------------------
// AddLink
inline bool Link::AddLink(unsigned long ulPg)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 80*4+6+1;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_unNe + 1 > 80)
		return FALSE;

	// add the data to the buffer stream
 	memcpy((m_pbyData+m_nDataLen), &ulPg, 4);

	m_nDataLen = m_nDataLen + 4;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : Link
// -------------------------------------------------------------------------
// Init
inline bool Link::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, (pbyData+4), 2);
	m_nDataLen = m_unNe*4+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : WLink
// Description: WLink (Data Type D24)
//
class WLink : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	WLink(){};

	// -------------------------------------------------------------------------
	// Constructor - construct the WLink by data stream
	WLink(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the nth WLink
	bool GetWLink(short nIndex, unsigned long &ulPg, unsigned short &unCur, float &fWt, unsigned short &unCU);

	// -------------------------------------------------------------------------
	// add the WLink to the array
	bool AddWLink(unsigned long ulPg, unsigned short unCur, float fWt, unsigned short unCU);

	// -------------------------------------------------------------------------
	// Init the WLink
	bool Init(byte* pbyData);
};

// Class      : WLink
// -------------------------------------------------------------------------
// GetWLink - start from 0
inline bool WLink::GetWLink(short nIndex, unsigned long &ulPg, unsigned short &unCur, float &fWt, unsigned short &unCU)
{
	if (nIndex < m_unNe)
	{
		memcpy(&ulPg, (m_pbyData+6+nIndex*12), 4);
		memcpy(&unCur, (m_pbyData+10+nIndex*12), 2);
		memcpy(&fWt, (m_pbyData+12+nIndex*12), 4);
		memcpy(&unCU, (m_pbyData+16+nIndex*12), 2);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : WLink
// -------------------------------------------------------------------------
// AddWLink
inline bool WLink::AddWLink(unsigned long ulPg, unsigned short unCur, float fWt, unsigned short unCU)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 30*12+6+1;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_unNe + 1 > 30)
		return FALSE;

	// add the data to the buffer stream
	memcpy((m_pbyData+m_nDataLen), &ulPg, 4);
	memcpy((m_pbyData+m_nDataLen+4), &unCur, 2);
	memcpy((m_pbyData+m_nDataLen+6), &fWt, 4);
	memcpy((m_pbyData+m_nDataLen+10), &unCU, 2);

	m_nDataLen = m_nDataLen + 12;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : WLink
// -------------------------------------------------------------------------
// Init
inline bool WLink::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, (pbyData+4), 2);
	m_nDataLen = m_unNe*12+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : MtcPoints
// Description: MtcPoints (Data Type D28)
//
class MtcPoints : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	MtcPoints(){};

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MtcPoints(byte* pbyData){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the nth Point
	bool GetPoint(short nIndex, byte &byPoint);
	
	// -------------------------------------------------------------------------
	// add the Point to the array
	bool AddPoint(byte byPoint);

	// -------------------------------------------------------------------------
	// Init the MtcPoints
	bool Init(byte* pbyData);
};

// Class      : MtcPoints
// -------------------------------------------------------------------------
// GetPoint - start from 0
inline bool MtcPoints::GetPoint(short nIndex, byte &byPoint)
{
	if (nIndex < m_unNe)
	{
		byPoint = *(m_pbyData+6+nIndex);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : MtcPoints
// -------------------------------------------------------------------------
// AddPoint
inline bool MtcPoints::AddPoint(byte byPoint)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 256+6+1;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_unNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	*(m_pbyData+m_nDataLen) = byPoint;

	m_nDataLen = m_nDataLen + 1;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : MtcPoints
// -------------------------------------------------------------------------
// Init
inline bool MtcPoints::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, (pbyData+4), 2);
	m_nDataLen = m_unNe+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : MtcVal
// Description: MtcVal (Data Type D29)
//
class MtcVal : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	MtcVal(){};

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MtcVal(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the nth Val
	bool GetVal(short nIndex, float &fVal);

	// -------------------------------------------------------------------------
	// add the Val to the array
	bool AddVal(float fVal);

	// -------------------------------------------------------------------------
	// Init the MtcVal
	bool Init(byte* pbyData);
};

// Class      : MtcVal
// -------------------------------------------------------------------------
// GetTime - start from 0
inline bool MtcVal::GetVal(short nIndex, float &fVal)
{
	if (nIndex < m_unNe)
	{
		memcpy(&fVal, (m_pbyData+6+nIndex*4), 4);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : MtcVal
// -------------------------------------------------------------------------
// AddUFloat
inline bool MtcVal::AddVal(float fVal)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 256*4+6+1;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_unNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy((m_pbyData+m_nDataLen), &fVal, 4);

	m_nDataLen = m_nDataLen + 4;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : MtcVal
// -------------------------------------------------------------------------
// Init
inline bool MtcVal::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, (pbyData+4), 2);
	m_nDataLen = m_unNe*4+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// DtcElement structure
// A Structure to hold the Dtc Elements of DtcPoints
//
/*struct DtcElement
{
	byte	m_byHT;					// the position of y-axis of high
	byte	m_byLW;					// the position of y-axis of low
	byte	m_byCLS;				// the position of y-axis of close
};*/

/////////////////////////////////////////////////////////////////////////////
//
// Class      : DtcPoints
// Description: DtcPoints (Data Type D30)
//
class DtcPoints : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	DtcPoints():m_byNe(0){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	DtcPoints(byte* pbyData):m_byNe(0){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
//	virtual ~DtcPoints();

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth DtcElement
	bool GetDtcElement(short nIndex, byte &byHT, byte &byLW, byte &byCLS);

	// -------------------------------------------------------------------------
	// Add DtcElement to the array
	bool AddDtcElement(byte byHT, byte byLW, byte byCLS);

	// -------------------------------------------------------------------------
	// Init the DtcPoints
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

private:
// Attributes
	byte m_byNe;
};

// Class      : DtcPoints
// -------------------------------------------------------------------------
// GetDtcElement - start from 0
inline bool DtcPoints::GetDtcElement(short nIndex, byte &byHT, byte &byLW, byte &byCLS)
{
	if (nIndex < m_byNe)
	{
		memcpy(&byHT, (m_pbyData+1+3*nIndex), 1);
		memcpy(&byLW, (m_pbyData+2+3*nIndex), 1);
		memcpy(&byCLS, (m_pbyData+3+3*nIndex), 1);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : DtcPoints
// -------------------------------------------------------------------------
// AddDtcElement
inline bool DtcPoints::AddDtcElement(byte byHT, byte byLW, byte byCLS)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 3*256 + 2;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy((m_pbyData+m_nDataLen), &byHT, 1);
	memcpy((m_pbyData+m_nDataLen+1), &byLW, 1);
	memcpy((m_pbyData+m_nDataLen+2), &byCLS, 1);

	m_nDataLen = m_nDataLen + 3;
	m_byNe = m_byNe + 1;
	*(m_pbyData) = m_byNe;
	return TRUE;

	return TRUE;
}

// Class      : DtcPoints
// -------------------------------------------------------------------------
// Init
inline bool DtcPoints::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	m_nDataLen = m_byNe*3+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : DtcPoints
// -------------------------------------------------------------------------
// GetData
inline byte* DtcPoints::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : HisVal
// Description: HisVal (Data Type D31)
//
class HisVal : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	HisVal():m_unTL(0), m_unNe(0), m_Dt(){m_nDataLen = 8;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	HisVal(byte* pbyData):m_unTL(0), m_unNe(0), m_Dt(){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
//	virtual ~HisVal();

// Operations
	// -------------------------------------------------------------------------
	// Get the Total number of Vals
	unsigned short GetTL()	{return m_unTL;}

	// -------------------------------------------------------------------------
	// Get the number of element
	unsigned short GetNe()	{return m_unNe;}

	// -------------------------------------------------------------------------
	// Get the position
	bool GetDt(BDateYear &Dt);
	
	// -------------------------------------------------------------------------
	// Get the nth DtcElement
	bool GetVal(short nIndex, float &fHT, float &fLW, float &fCLS, unsigned long &ulVol);
	
	// -------------------------------------------------------------------------
	// Set the Total number of Vals
	void SetTL(unsigned short unTL)	{m_unTL = unTL;}

	// -------------------------------------------------------------------------
	// Set the number of postition
	void SetDt(BDateYear Dt)	{m_Dt = Dt;}

	// -------------------------------------------------------------------------
	// Add DtcElement to the array
	bool AddVal(float fHT, float fLW, float CLS, unsigned long ulVol);

	// -------------------------------------------------------------------------
	// Init the HisVal
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get Data
	byte* GetData();

private:
// Attributes
	unsigned short	m_unTL;		// Total number of element
	unsigned short	m_unNe;		// number of elements in the list
	BDateYear		m_Dt;		// the Date of the first in this field
};

// Class      : HisVal
// -------------------------------------------------------------------------
// GetDtcElement - start from 0
inline bool HisVal::GetVal(short nIndex, float &fHT, float &fLW, float &fCLS, unsigned long &ulVol)
{
	if (nIndex < m_unNe)
	{
		memcpy(&fHT, (m_pbyData+8+16*nIndex), 4);
		memcpy(&fLW, (m_pbyData+12+16*nIndex), 4);
		memcpy(&fCLS, (m_pbyData+16+16*nIndex), 4);
		memcpy(&ulVol, (m_pbyData+20+16*nIndex), 4);
		return TRUE;
	}
	else
		return FALSE;
}


// Class      : HisVal
// -------------------------------------------------------------------------
// GetDt
inline bool HisVal::GetDt(BDateYear &Dt)
{
	if (Dt.Init(m_Dt.GetData()))
		return TRUE;
	else
		return FALSE;
}

// Class      : HisVal
// -------------------------------------------------------------------------
// AddDtcElement
inline bool HisVal::AddVal(float fHT, float fLW, float fCLS, unsigned long ulVol)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 16*20+9;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_unNe + 1 > 20)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &fHT, 4);
	memcpy(m_pbyData+m_nDataLen+4, &fLW, 4);
	memcpy(m_pbyData+m_nDataLen+8, &fCLS, 4);
	memcpy(m_pbyData+m_nDataLen+12, &ulVol, 4);

	m_nDataLen = m_nDataLen + 16;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : HisVal
// -------------------------------------------------------------------------
// Init
inline bool HisVal::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	m_Dt.Init(pbyData+4);
	m_nDataLen = m_unNe*16+8;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : HisVal
// -------------------------------------------------------------------------
// GetData
inline byte* HisVal::GetData()
{
	ASSERT(m_unTL >= m_unNe && m_unNe >=0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	memcpy(m_pbyData, &m_unTL, 2);
	memcpy(m_pbyData+2, &m_unNe, 2);
	memcpy(m_pbyData+4, m_Dt.GetData(), 4);
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : FieldList
// Description: FieldList (Data Type D32)
//
class FieldList : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	FieldList():m_byNe(0){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor by byte stream
	FieldList(byte* pbyData):m_byNe(0){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth Field
	bool GetField(short nIndex, unsigned short &unField);

	// -------------------------------------------------------------------------
	// Add Field to the array
	bool AddField(unsigned short unField);

	// -------------------------------------------------------------------------
	// Init the FieldList
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

private:
// Attributes
	byte m_byNe;
};

// Class      : FieldList
// -------------------------------------------------------------------------
// GetUFloat - start from 0
inline bool FieldList::GetField(short nIndex, unsigned short &unField)
{
	if (nIndex < m_byNe)
	{
		memcpy(&unField, (m_pbyData+1+2*nIndex), 2);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : FieldList
// -------------------------------------------------------------------------
// AddUFloat
inline bool FieldList::AddField(unsigned short unField)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 256*2+2;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &unField, 2);

	m_nDataLen = m_nDataLen + 2;
	m_byNe = m_byNe + 1;
	*(m_pbyData) = m_byNe;
	return TRUE;
}

// Class      : FieldList
// -------------------------------------------------------------------------
// Init
inline bool FieldList::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	m_nDataLen = m_byNe*2+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : FieldList
// -------------------------------------------------------------------------
// GetData
inline byte* FieldList::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : FieldLabel
// Description: FieldLabel (Data Type D33)
//
class FieldLabel : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	FieldLabel():m_byNe(0), m_pnStrPosArray(NULL){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	FieldLabel(byte* pbyData):m_byNe(0), m_pnStrPosArray(NULL){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
	~FieldLabel();

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth Label - user must new the pcLabel before passing in
	bool GetLabel(short nIndex, char* pcLabel, byte byMaxLen);

	// -------------------------------------------------------------------------
	// Add Label to the array
	bool AddLabel(char* pcLabel);

	// -------------------------------------------------------------------------
	// Init the FieldLabel
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

protected:
// Operation
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();

private:
// Attributes
	byte	m_byNe;
	short*	m_pnStrPosArray;		// An array to store the Label length position
									// in the internal byte stream
};

// Class      : FieldLabel
// -------------------------------------------------------------------------
// Default Destructor
inline FieldLabel::~FieldLabel()
{
	ClearData();
}

// Class      : FieldLabel
// -------------------------------------------------------------------------
// ClearData
inline void FieldLabel::ClearData()
{
    if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}

	if (m_pnStrPosArray)
	{
		delete[] m_pnStrPosArray;
		m_pnStrPosArray = NULL;
	}
}

// Class      : FieldLabel
// -------------------------------------------------------------------------
// GetLabel - start from 0
inline bool FieldLabel::GetLabel(short nIndex, char* pcLabel, byte byMaxLen)
{
	if ((nIndex < m_byNe) && (pcLabel) && (m_byNe > 0))
	{
		// check whether the input len is enough to copy the byte stream
		byte byStrLen = *(m_pbyData+*(m_pnStrPosArray+nIndex));
		memset(pcLabel, 0, byMaxLen);
		if (byMaxLen > byStrLen)
			memcpy(pcLabel, (m_pbyData+*(m_pnStrPosArray+nIndex)+1), byStrLen);
		else
			memcpy(pcLabel, (m_pbyData+*(m_pnStrPosArray+nIndex)+1), byStrLen-1);
		return TRUE;
	}
	return FALSE;
}

// Class      : FieldLabel
// -------------------------------------------------------------------------
// AddUFloat
inline bool FieldLabel::AddLabel(char* pcLabel)
{
	if ((!m_bDataChanged) || (strlen(pcLabel) > 255))
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
		m_pnStrPosArray = new short[256];
		memset(m_pnStrPosArray, 0, 256);
	}

	// check whether it overflow the limit
	byte byLen = strlen(pcLabel) + 1;
	if ((m_byNe + 1 > 256) || (byLen + 1 + m_nDataLen >= m_nBufferSize))
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &byLen, 1);
	memcpy(m_pbyData+m_nDataLen+1, pcLabel, byLen);

	m_nDataLen = m_nDataLen + byLen + 1;
	*(m_pbyData) = m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : FieldLabel
// -------------------------------------------------------------------------
// Init
inline bool FieldLabel::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData) 
		return FALSE;

	m_byNe = *pbyData;
	if (m_byNe == 0)
		m_nDataLen = 1;
	else
	{
		m_pnStrPosArray = new short[m_byNe];
		memset(m_pnStrPosArray, 0, m_byNe);
		*m_pnStrPosArray = 1;
		m_nDataLen = 2 + *(pbyData+1);
		for (int i=1; i<m_byNe;i++)
		{
			*(m_pnStrPosArray+i) = m_nDataLen;
			m_nDataLen = m_nDataLen + *(pbyData+m_nDataLen) + 1;
		}
	}
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short FieldLabel::GetByteLength(byte* pbyData)
{
	byte ne = *pbyData;
	if (ne == 0)
		return 1;
	
	unsigned short size = 2 + *(pbyData + 1);

	for (int i = 1; i < ne; i++){
		size += *(pbyData + size) + 1;
	}
	return size;

}

// Class      : FieldLabel
// -------------------------------------------------------------------------
// GetData
inline byte* FieldLabel::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : InfoMsg
// Description: InfoMsg (Data Type D34)
//
class InfoMsg : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	InfoMsg():m_byTL(0), m_byNe(0), m_pnInfoPosArray(NULL){m_nDataLen = 2;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	InfoMsg(byte* pbyData):m_byTL(0), m_byNe(0), m_pnInfoPosArray(NULL){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
	~InfoMsg();

// Operations
	// -------------------------------------------------------------------------
	// Get the Total number
	byte GetTL()	{return m_byTL;}

	// -------------------------------------------------------------------------
	// Get the Line number
//	byte GetLn()	{return m_byLn;}

	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth Label - user must new the pcLabel before passing in
//	bool GetLabel(short nIndex, char* pcLabel, byte byMaxLen, unsigned long &ulPg, unsigned short &unFd);
	bool GetInfo(short nIndex, char* pcLabel, byte byMaxLen, unsigned long &ulPg, unsigned short &unFd);

	// -------------------------------------------------------------------------
	// Get the nth Page number
//	bool GetPg(short nIndex, unsigned long &ulPg);

	// -------------------------------------------------------------------------
	// Get the nth field code
//	bool GetFd(short nIndex, unsigned short &unFd);

	// -------------------------------------------------------------------------
	// Set the Total number of Vals
	void SetTL(byte byTL)	{m_byTL = byTL;}

	// -------------------------------------------------------------------------
	// Set the Line Number
//	void SetLn(byte byLn)	{m_byLn = byLn;}

	// -------------------------------------------------------------------------
	// Add Info to the array
	bool AddInfo(char* pcLabel, unsigned long ulPg, unsigned short unFd);

	// -------------------------------------------------------------------------
	// Init the InfoMsg
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);

	// -------------------------------------------------------------------------
	// GetData
	byte* GetData();

private:
// Attributes
	byte	m_byTL;					// Total number of Array
//	byte	m_byLn;					// Line Number
	byte	m_byNe;					// Total number of element
	short*	m_pnInfoPosArray;		// An array to store the Label length position
									// in the internal byte stream

protected:
// Operation
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();
};

// Class      : InfoMsg
// -------------------------------------------------------------------------
// Default Destructor
inline InfoMsg::~InfoMsg()
{
	ClearData();
}

// Class      : InfoMsg
// -------------------------------------------------------------------------
// ClearData
inline void InfoMsg::ClearData()
{
    if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}

	if (m_pnInfoPosArray)
	{
		delete[] m_pnInfoPosArray;
		m_pnInfoPosArray = NULL;
	}
}

// Class      : InfoMsg
// -------------------------------------------------------------------------
// GetLabel - start from 0
inline bool InfoMsg::GetInfo(short nIndex, char* pcLabel, byte byMaxLen, unsigned long &ulPg, unsigned short &unFd)
{
	if ((nIndex < m_byNe) && (pcLabel) && (m_byNe > 0))
	{
		// check whether the input len is enough to copy the byte stream
		byte byStrLen = *(m_pbyData+*(m_pnInfoPosArray+nIndex));
		memset(pcLabel, 0, byMaxLen);
		if (byMaxLen > byStrLen)
			memcpy(pcLabel, (m_pbyData+*(m_pnInfoPosArray+nIndex)+1), byStrLen);
		else
			memcpy(pcLabel, (m_pbyData+*(m_pnInfoPosArray+nIndex)+1), byStrLen-1);

		if (nIndex == m_byNe-1)
		{
			memcpy(&ulPg, (m_pbyData+m_nDataLen-6), 4);
			memcpy(&unFd, (m_pbyData+m_nDataLen-2), 2);
		}
		else
		{
			memcpy(&ulPg, (m_pbyData+*(m_pnInfoPosArray+nIndex+1)-6), 4);
			memcpy(&unFd, (m_pbyData+*(m_pnInfoPosArray+nIndex+1)-2), 2);
		}
		return TRUE;
	}
	return FALSE;
}

// Class      : InfoMsg
// -------------------------------------------------------------------------
// GetData
inline byte* InfoMsg::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byTL;
//	*(m_pbyData+1) = m_byLn;
	*(m_pbyData+1) = m_byNe;
	return m_pbyData;
}

// Class      : InfoMsg
// -------------------------------------------------------------------------
// GetLink - start from 0
/*inline bool InfoMsg::GetPg(short nIndex, )
{
	if ((nIndex < m_byNe) && (m_byNe > 0))
	{
	}
	return FALSE;
}

// Class      : InfoMsg
// -------------------------------------------------------------------------
// GetFd - start from 0
inline bool InfoMsg::GetFd(short nIndex, )
{
	if ((nIndex < m_byNe) && (m_byNe > 0))
	{
	}
	return FALSE;
}
*/
// Class      : InfoMsg
// -------------------------------------------------------------------------
// AddInfo
inline bool InfoMsg::AddInfo(char* pcLabel, unsigned long ulPg, unsigned short unFd)
{
	if ((!m_bDataChanged) || (strlen(pcLabel) > 255))
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
		m_pnInfoPosArray = new short[256];
		memset(m_pnInfoPosArray, 0, 256);
	}

	// check whether it overflow the limit
	byte byLen = strlen(pcLabel);
	if ((m_byNe + 1 > 256) || (byLen + m_nDataLen >= m_nBufferSize))
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &byLen, 1);
	memcpy(m_pbyData+m_nDataLen+1, pcLabel, byLen);
	memcpy(m_pbyData+m_nDataLen+1+byLen, &ulPg, 4);
	memcpy(m_pbyData+m_nDataLen+5+byLen, &unFd, 2);

	m_nDataLen = m_nDataLen + 7 + byLen;
	m_byNe = m_byNe + 1;
	*(m_pbyData+1) = m_byNe;
	*(m_pnInfoPosArray+m_byNe-1) = m_nDataLen;
	return TRUE;
}

// Class      : InfoMsg
// -------------------------------------------------------------------------
// Init
inline bool InfoMsg::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData) 
		return FALSE;

	m_byTL = *pbyData;
//	m_byLn = *(pbyData+1);
	m_byNe = *(pbyData+1);
	if (m_byNe == 0)
		m_nDataLen = 2;
	else
	{
		m_pnInfoPosArray = new short[m_byNe];
		memset(m_pnInfoPosArray, 0, m_byNe*2);
		*m_pnInfoPosArray = 2;
		m_nDataLen = 2 + *(pbyData+2)+7;
		for (int i=1; i<m_byNe;i++)
		{
			*(m_pnInfoPosArray+i) = m_nDataLen;
			m_nDataLen = m_nDataLen + *(pbyData+m_nDataLen) + 7;
		}
	}
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}


inline unsigned short InfoMsg::GetByteLength(byte* pbyData)
{
	byte ne = *(pbyData +1);
	if (ne == 0)
		return 2;

	unsigned short size = 2 + *(pbyData + 2) + 7;

	for (int i = 1; i < ne; i++){
		size += *(pbyData + size) + 7;
	}
	return size;

}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : HeadLine
// Description: HeadLine (Data Type D35)
//
class HeadLine : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	HeadLine():m_plTopicCode(NULL){};

	// -------------------------------------------------------------------------
	// Constructor
	HeadLine(unsigned long unLn, 
			BDateMonth dt, 
			BTimeSec tm, 
			byte byType,
			char* pcLg,
			unsigned long ulPg, 
			char* pcPNAC, 
			char* pcTopicCode, 
			byte byNe,							// 1
			unsigned long *pulPg,				// byNe * 4
			char* pcString);

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	HeadLine(byte* pbyData):m_plTopicCode(NULL)	{Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default destructor
	~HeadLine();

// Operations
	// -------------------------------------------------------------------------
	// Get the HeadLine
	bool GetHeadLine(unsigned long &unLn,		// 2
			BDateMonth &dt,						// 2
			BTimeSec &tm,						// 2
			byte &byType,						// 1
			char* pcLg,							// 
			unsigned long &ulPg,				// 4
			char* pcPNAC,						// m_byLen2
			char* pcTopicCode,					// unNo*4
			byte &byNe,							// 1
			unsigned long *pulPg,				// byNe*4
			char* pcString);					// byLen;

	// -------------------------------------------------------------------------
	// Init the HeadLine
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);

private:
// attribute
	unsigned short m_unLg;
	long* m_plTopicCode;
	byte m_byNe;
	byte m_byNe2;
	byte m_byLen;
	byte m_byLen2;

// operation
	// -------------------------------------------------------------------------
	// Get the value of char
	byte GetVal(byte byChar);

	// -------------------------------------------------------------------------
	// Encode the 2 bytes and 4 bytes data
	bool Encode(char* pcLg, char* pcTopicCode);

protected:
	// -------------------------------------------------------------------------
	// ClearData
	void ClearData();
};

// Class      : HeadLine
// -------------------------------------------------------------------------
// GetHeadLine - start from 0
inline HeadLine::~HeadLine()
{
	ClearData();
}

// Class      : HeadLine
// -------------------------------------------------------------------------
// ClearData
inline void HeadLine::ClearData()
{
	if (m_pbyData)
	{
		delete [] m_pbyData;
		m_pbyData = NULL;
	}
	if (m_plTopicCode)
	{
		delete [] m_plTopicCode;
		m_plTopicCode = NULL;
	}
}

// Class      : HeadLine
// -------------------------------------------------------------------------
// Constructor by user input, all the strings must be null-terminated
inline HeadLine::HeadLine(unsigned long unLn,	// 2
			BDateMonth dt,						// 2
			BTimeSec tm,						// 3
			byte byType,						// 1
			char* pcLg,							// 2
			unsigned long ulPg,					// 4
			char* pcPNAC,						// m_byLen2
			char* pcTopicCode,					// 4*m_byNe + 1
			byte byNe,							// 1
			unsigned long *pulPg,				// byNe * 4
			char* pcString)						// m_byLen+1
{
	m_pbyData = NULL;
	m_nDataLen = 0;

	m_unLg = 0;
	m_plTopicCode = NULL;
	m_byNe = 0;

	// check the string, if no data, do not construct
	if ((!pcLg) || (!pcTopicCode) || (!pcString) || (!pcPNAC))
		return;

	m_byLen2 = strlen(pcPNAC);
//	if (m_byLen2 > 17)
//		return;

	if (!Encode(pcLg, pcTopicCode))
		return;

	m_byLen = strlen(pcString);
	if (m_byLen>255)
		m_byLen = 255;
	m_nDataLen = 4+2+3+1+2+4+1+m_byLen2+m_byNe*4+1+m_byLen+1+byNe*4+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);

	memcpy(m_pbyData, &unLn, 4);
	memcpy(m_pbyData+4, dt.GetData(), 2);
	memcpy(m_pbyData+6, tm.GetData(), 3);
	memcpy(m_pbyData+9, &byType, 1);
	memcpy(m_pbyData+10, &m_unLg, 2);
	memcpy(m_pbyData+12, &ulPg, 4);
	memcpy(m_pbyData+16, &m_byLen2, 1);
	memcpy(m_pbyData+17, pcPNAC, m_byLen2);
	memcpy(m_pbyData+17+m_byLen2, &m_byNe, 1);
	memcpy(m_pbyData+18+m_byLen2, (byte*)m_plTopicCode, m_byNe*4);
	memcpy(m_pbyData+18+m_byLen2+m_byNe*4, &byNe, 1);
	memcpy(m_pbyData+19+m_byLen2+m_byNe*4, pulPg, byNe*4);
	memcpy(m_pbyData+19+m_byLen2+m_byNe*4+byNe*4, &m_byLen, 1);
	memcpy(m_pbyData+20+m_byLen2+m_byNe*4+byNe*4, pcString, m_byLen);
}

// Class      : HeadLine
// -------------------------------------------------------------------------
// GetHeadLine
inline bool HeadLine::GetHeadLine(unsigned long &unLn,		// 2
			BDateMonth &dt,									// 2
			BTimeSec &tm,									// 2
			byte &byType,									// 1
			char* pcLg,										// 
			unsigned long &ulPg,							// 4
			char* pcPNAC,									// byLen2
			char* pcTopicCode,								// unNo*4
			byte &byNe,										// 1
			unsigned long *pulPg,							// byNe*4
			char* pcString)									// byLen
{
	if (!m_pbyData)
		return FALSE;

	char cCharArray[34] = "0ABCDEFGHIJKLMNOPQRSTUVWXYZ /\\.=";
	memcpy(&unLn, m_pbyData, 4);
	dt.Init(m_pbyData+4);
	tm.Init(m_pbyData+6);
	memcpy(&byType, m_pbyData+9, 1);
	// decode the language ID
	memcpy(&m_unLg, m_pbyData+10, 2);
	byte byChar = 0;
	for(int i = 0; i<3; i++)
	{
		byChar = cCharArray[(byte) ((m_unLg >> (16-(i+1)*5)) & 0x1F)];
		if (byChar != '0')
			*(pcLg+i) = byChar;
	}

	memcpy(&ulPg, m_pbyData+12, 4);
	memcpy(&m_byLen2, m_pbyData+16, 1);
	memcpy(pcPNAC, m_pbyData+17, m_byLen2);
	memcpy(&m_byNe, m_pbyData+17+m_byLen2, 1);
	// decode the topic code
	if (!m_plTopicCode)
		m_plTopicCode = new long[m_byNe];
	memset(m_plTopicCode, 0, m_byNe*4);
	memcpy((byte*) m_plTopicCode, m_pbyData+18+m_byLen2, m_byNe*4);
	long tmpTopicCode = 0;
	int counter;
	int j = 0;
	for(int i = 0; i<m_byNe; i++)
	{
		tmpTopicCode = *(m_plTopicCode+i);
		for(counter = 1; counter < 7; counter++) 
		{
			byChar = cCharArray[(byte) ((tmpTopicCode >> (32-counter*5)) & 0x1F)];
			if (byChar != '0')
			{
				*(pcTopicCode+j) = byChar;
				j++;
			}
		}
		if (i+1 < m_byNe)
		{
			*(pcTopicCode + j) = ' ';
			j++;
		}
	}

	// Get the ne1 of page no.
	memcpy(&byNe, m_pbyData+18+m_byLen2+m_byNe*4, 1);
	memcpy(pulPg, m_pbyData+19+m_byLen2+m_byNe*4, byNe*4);
	memcpy(&m_byLen, m_pbyData+19+m_byLen2+m_byNe*4+byNe*4, 1);
	memcpy(pcString, m_pbyData+20+m_byLen2+m_byNe*4+byNe*4, m_byLen);
	return TRUE;
}

// Class      : HeadLine
// -------------------------------------------------------------------------
// Init
inline bool HeadLine::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	m_plTopicCode = NULL;
	memcpy(&m_byLen2, pbyData+16, 1);
	memcpy(&m_byNe, pbyData+17+m_byLen2, 1);
	memcpy(&m_byNe2, pbyData+18+m_byNe*4+m_byLen2, 1);
	m_nDataLen = 19+m_byNe*4+m_byNe2*4+m_byLen2;
	m_nDataLen = m_nDataLen + *(pbyData+m_nDataLen) + 1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}


inline unsigned short HeadLine::GetByteLength(byte* pbyData)
{
	byte byLen2, byNe, byNe2;
	memcpy(&byLen2, pbyData + 16, 1);
	memcpy(&byNe, pbyData + 17 + byLen2, 1);
	memcpy(&byNe2, pbyData + 18 + byNe * 4 + byLen2, 1);
	unsigned short size = 19 + byNe * 4 + byNe2 * 4 + byLen2;
	size = size + *(pbyData + size) + 1;
	return size;

}

// Class      : HeadLine
// -------------------------------------------------------------------------
// GetVal
inline byte HeadLine::GetVal(byte byChar)
{
	byte byVal = 0;
	switch (byChar)
	{
		case 'A':
			byVal = 1;
			break;
		case 'B':
			byVal = 2;
			break;
		case 'C':
			byVal = 3;
			break;
		case 'D':
			byVal = 4;
			break;
		case 'E':
			byVal = 5;
			break;
		case 'F':
			byVal = 6;
			break;
		case 'G':
			byVal = 7;
			break;
		case 'H':
			byVal = 8;
			break;
		case 'I':
			byVal = 9;
			break;
		case 'J':
			byVal = 10;
			break;
		case 'K':
			byVal = 11;
			break;
		case 'L':
			byVal = 12;
			break;
		case 'M':
			byVal = 13;
			break;
		case 'N':
			byVal = 14;
			break;
		case 'O':
			byVal = 15;
			break;
		case 'P':
			byVal = 16;
			break;
		case 'Q':
			byVal = 17;
			break;
		case 'R':
			byVal = 18;
			break;
		case 'S':
			byVal = 19;
			break;
		case 'T':
			byVal = 20;
			break;
		case 'U':
			byVal = 21;
			break;
		case 'V':
			byVal = 22;
			break;
		case 'W':
			byVal = 23;
			break;
		case 'X':
			byVal = 24;
			break;
		case 'Y':
			byVal = 25;
			break;
		case 'Z':
			byVal = 26;
			break;
		case ' ':
			byVal = 27;
			break;
		case '/':
			byVal = 28;
			break;
		case '\\':
			byVal = 29;
			break;
		case '.':
			byVal = 30;
			break;
		case '=':
			byVal = 31;
			break;
		default:
			byVal = 0;
			break;
	}
	return byVal;
}

// Class      : HeadLine
// -------------------------------------------------------------------------
// Encode
inline bool HeadLine::Encode(char* pcLg, char* pcTopicCode)
{
	short nStrLen = 0;
	// Generate the Language ID
	nStrLen = strlen(pcLg);
	if (nStrLen > 3)
		nStrLen = 3;
	for(int i = 0; i < nStrLen; i++)
		m_unLg = m_unLg + ( ((unsigned short) GetVal(*(pcLg+i))) << (16-5*(i+1)) );

	// Generate the TopicCode Array
	int counter = 1;
	unsigned long tmpTopicCode = 0;

	nStrLen = strlen(pcTopicCode);
	if (nStrLen > 255)
		nStrLen = 255;
	m_plTopicCode = new long[nStrLen];
	memset(m_plTopicCode, 0, 4*nStrLen);
	for(int i = 0; i<nStrLen+1; i++)
	{
		if ((*(pcTopicCode+i) != ' ') && (*(pcTopicCode+i) != 0))
		{
			if (counter+1 > 7)
				return FALSE;
			tmpTopicCode = tmpTopicCode + (((unsigned long) GetVal(*(pcTopicCode+i))) << (32-5*counter));
			counter++;
		}
		else
		{
			if (tmpTopicCode != 0)
			{
				*(m_plTopicCode+m_byNe) = tmpTopicCode;
				tmpTopicCode = 0;
				m_byNe++;
			}
			counter = 1;
		}
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : HLink
// Description: HLink (Data Type D36)
//
class HLink : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	HLink():m_byTL(0), m_byNe(0), m_byPos(0){m_nDataLen = 3;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	HLink(byte* pbyData):m_byTL(0), m_byNe(0), m_byPos(0){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default Destructor
//	virtual ~HLink();

// Operations
	// -------------------------------------------------------------------------
	// Get the Total number of Vals
	byte GetTL()	{return m_byTL;}

	// -------------------------------------------------------------------------
	// Get the position of first element
	byte GetPos()	{return m_byPos;}

	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}
	
	// -------------------------------------------------------------------------
	// Get the nth Headline link
	bool GetHLink(short nIndex, unsigned long &ulPg, unsigned long &ulLn);
	
	// -------------------------------------------------------------------------
	// Set the Total number of Vals
	void SetTL(byte byTL)	{m_byTL = byTL;}

	// -------------------------------------------------------------------------
	// Set the position of first element
	void SetPos(byte byPos)	{m_byPos = byPos;}

	// -------------------------------------------------------------------------
	// Add Headline link to the array
	bool AddHLink(unsigned long ulPg, unsigned long ulLn);

	// -------------------------------------------------------------------------
	// Init the HLink
	bool Init(byte* pbyData);

	// -------------------------------------------------------------------------
	// GetData
	byte* GetData();

private:
// Attributes
	byte			m_byTL;		// Total number of element
	byte			m_byNe;		// number of elements in the list
	byte			m_byPos;	// position of the first element
	BDateYear		m_Dt;		// the Date of the first in this field
};

// Class      : HLink
// -------------------------------------------------------------------------
// GetHLink - start from 0
inline bool HLink::GetHLink(short nIndex, unsigned long &ulPg, unsigned long &ulLn)
{
	if (nIndex < m_byNe)
	{
		memcpy(&ulPg, (m_pbyData+3+8*nIndex), 4);
		memcpy(&ulLn, (m_pbyData+7+8*nIndex), 4);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : HLink
// -------------------------------------------------------------------------
// AddHLink
inline bool HLink::AddHLink(unsigned long ulPg, unsigned long ulLn)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 2048;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &ulPg, 4);
	memcpy(m_pbyData+m_nDataLen+4, &ulLn, 4);

	m_nDataLen = m_nDataLen + 8;
	m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : HLink
// -------------------------------------------------------------------------
// Init
inline bool HLink::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byTL = *(pbyData);
	m_byNe = *(pbyData+1);
	m_byPos = *(pbyData+2);
	m_nDataLen = m_byNe*8+3;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

// Class      : HLink
// -------------------------------------------------------------------------
// GetData
inline byte* HLink::GetData()
{
	ASSERT(m_byTL >= m_byNe + m_byPos && m_byNe >= 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byTL;
	*(m_pbyData+1) = m_byNe;
	*(m_pbyData+2) = m_byPos;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : MShrOrdLst
// Description: Multi Share Order list - type 37
//
class MShrOrdLst : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	MShrOrdLst():m_byNe(0){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MShrOrdLst(byte* pbyData):m_byNe(0){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth ShrOrdLst
	bool GetShrOrdLst(short nIndex, ShrOrdLst &shrordlst);
	
	// -------------------------------------------------------------------------
	// add the ShrOrdLst to the array
	bool AddShrOrdLst(ShrOrdLst* pShrOrdLst);

	// -------------------------------------------------------------------------
	// Init the MShrOrdLst
	bool Init(byte* pbyData);

private:
// Attributes
	byte m_byNe;
};

// Class      : MShrOrdLst
// -------------------------------------------------------------------------
// GetShrOrdLst - start from 0
inline bool MShrOrdLst::GetShrOrdLst(short nIndex, ShrOrdLst &shrordlst)
{
	if (nIndex < m_byNe)
	{
		shrordlst.Init(m_pbyData+1+4*nIndex);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : MShrOrdLst
// -------------------------------------------------------------------------
// AddShrOrdLst
inline bool MShrOrdLst::AddShrOrdLst(ShrOrdLst* pShrOrdLst)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1026;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, pShrOrdLst->GetData(), pShrOrdLst->GetDataLen());
	m_nDataLen = m_nDataLen + 4;
	*(m_pbyData) = m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : MShrOrdLst
// -------------------------------------------------------------------------
// Init
inline bool MShrOrdLst::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	m_nDataLen = m_byNe*4+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : SprTbl
// Description: SprTbl (Data Type D38)
//
class SprTbl : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	SprTbl(){};

	// -------------------------------------------------------------------------
	// Constructor - construct the SprTbl by data stream
	SprTbl(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the nth SprTbl
	bool GetSprTbl(short nIndex, float &fPF, float &fPT, float &fSpr);

	// -------------------------------------------------------------------------
	// add the SprTbl to the array
	bool AddSprTbl(float fPF, float fPT, float fSpr);

	// -------------------------------------------------------------------------
	// Init the SprTbl
	bool Init(byte* pbyData);
};

// Class      : SprTbl
// -------------------------------------------------------------------------
// GetSprTbl - start from 0
inline bool SprTbl::GetSprTbl(short nIndex, float &fPF, float &fPT, float &fSpr)
{
	if (nIndex < m_unNe)
	{
		memcpy(&fPF, (m_pbyData+6+12*nIndex), 4);
		memcpy(&fPT, (m_pbyData+10+12*nIndex), 4);
		memcpy(&fSpr, (m_pbyData+14+12*nIndex), 4);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : SprTbl
// -------------------------------------------------------------------------
// AddSprTbl
inline bool SprTbl::AddSprTbl(float fPF, float fPT, float fSpr)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 12*80+7;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_unNe + 1 > 80)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &fPF, 4);
	memcpy(m_pbyData+m_nDataLen+4, &fPT, 4);
	memcpy(m_pbyData+m_nDataLen+8, &fSpr, 4);

	m_nDataLen = m_nDataLen + 12;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : SprTbl
// -------------------------------------------------------------------------
// Init
inline bool SprTbl::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, pbyData+4, 2);
	m_nDataLen = m_unNe*12+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : QuoteList
// Description: QuoteList (Data Type D39)
// Protocol	  : <tl><ne>{<ln><fd><len><fv>)...}
//
class QuoteList : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	QuoteList()
	{
		InitMembers();
	};

	// -------------------------------------------------------------------------
	// Constructor - construct the SprTbl by data stream
	QuoteList(byte* pbyData)
	{
		InitMembers ();
		Init(pbyData);
	}

	virtual ~QuoteList()
	{
		ClearData();
	}

// Operations
	// -------------------------------------------------------------------------
	// Init the QuoteList
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	byte GetTL () { return m_byTL; };
	unsigned short GetNE () { return m_usNE; };
	void SetTL (byte byTL) { m_byTL = byTL; };

	bool AddQuote (byte byLn, short nFid, byte byLen, void* pFv);
	bool AddQuote (byte* pQuote, unsigned short usQuoteLen);

	bool GetQuote (unsigned short nIndex, byte& rLn, short& rFid, byte& rLen, void*& rFv);
	bool GetQuote (unsigned short nIndex, byte*& rQuote, unsigned short& rusQuoteLen);

	// This function will make a LINEAR SEARCH O(n) by byLn and nFid
	bool GetQuote (byte byLn, short nFid, byte& byLen, void*& pFv);

protected:
	byte				m_byTL;
	unsigned short		m_usNE;

	int*				m_pDataPosArray;		// Array of data position i.e. the indices of <ln>

	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();

	void InitMembers ();
	void ExpandBufferIfNeeded (unsigned short usLen);

	// some contants
	enum
	{
		LENGTHOF_TL = 1,
		LENGTHOF_NE	= 2,
		LENGTHOF_LN	= 1,
		LENGTHOF_FD	= 2,
		LENGTHOF_LEN = 1,

		LENGTHOF_TL_NE = LENGTHOF_TL + LENGTHOF_NE,
		LENGTHOF_LN_FD = LENGTHOF_LN + LENGTHOF_FD,
		LENGTHOF_LN_FD_LEN = LENGTHOF_LN_FD + LENGTHOF_LEN,

		BUFFER_BLOCK_SIZE = 512,
		MAX_NE = 65535,
	};
};


// Class      : QuoteList
// -------------------------------------------------------------------------
// InitMembers
inline void QuoteList::InitMembers ()
{
	m_byTL = 0;
	m_usNE = 0;
	m_pDataPosArray = NULL;
	m_nDataLen = LENGTHOF_TL_NE;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// ExpandBufferIfNeeded
inline void QuoteList::ExpandBufferIfNeeded (unsigned short usLen)
{
	if (m_pbyData == NULL)
	{
		m_pbyData = new byte[m_nBufferSize];
	}
	else
	{
		if (m_nDataLen + usLen + LENGTHOF_LN_FD_LEN >= m_nBufferSize)
		{
			ASSERT ( usLen + LENGTHOF_LN_FD_LEN < BUFFER_BLOCK_SIZE);
			m_nBufferSize += BUFFER_BLOCK_SIZE;
			byte* pbyNewBuffer = new byte[m_nBufferSize];
			memcpy (pbyNewBuffer, m_pbyData, m_nBufferSize - BUFFER_BLOCK_SIZE);

			delete [] m_pbyData;
			m_pbyData = pbyNewBuffer;
		}
	}
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// Init
inline bool QuoteList::Init(byte* pbyData)
{
	if (pbyData == NULL)
		return FALSE;

	ClearData();
	m_nDataLen = LENGTHOF_TL_NE;
	m_byTL = pbyData[0];
	m_usNE = *((short*) (pbyData+LENGTHOF_TL));

	ASSERT (m_pDataPosArray == NULL);
	m_pDataPosArray = new int[m_usNE];

	// first parse to find total data length
	for (WORD i=0; i<m_usNE; i++)
	{
		m_pDataPosArray[i] = m_nDataLen;
		m_nDataLen += LENGTHOF_LN_FD_LEN + *( pbyData + m_nDataLen + LENGTHOF_LN_FD );
	}

	m_pbyData = new byte[m_nDataLen];
	memcpy (m_pbyData, pbyData, m_nDataLen);

	m_bDataChanged = FALSE;

	return true;
}

inline unsigned short QuoteList::GetByteLength(byte* pbyData)
{
	unsigned short size = LENGTHOF_TL_NE;
	unsigned short ne = *((short*)(pbyData + LENGTHOF_TL));
	for (unsigned short i = 0; i < ne; i++)
	{
		size += LENGTHOF_LN_FD_LEN + *(pbyData + size + LENGTHOF_LN_FD);
	}
	return size;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// GetData
inline byte* QuoteList::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	m_pbyData[0] = m_byTL;
	memcpy (m_pbyData+LENGTHOF_LN, &m_usNE, sizeof(m_usNE));

	return m_pbyData;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// Init
inline bool QuoteList::AddQuote (byte byLn, short nFid, byte byLen, void* pFv)
{
	if (!m_bDataChanged || m_usNE >= MAX_NE)
		return FALSE;

	ExpandBufferIfNeeded(byLen);

	// add the data to the buffer stream
	*(m_pbyData+m_nDataLen) = byLn;
	m_nDataLen++;
	memcpy (m_pbyData+m_nDataLen, &nFid, sizeof(nFid));
	m_nDataLen += sizeof(nFid);
	*(m_pbyData+m_nDataLen) = byLen;
	m_nDataLen++;
	memcpy (m_pbyData+m_nDataLen, pFv, byLen);
	m_nDataLen += byLen;

	m_usNE++;

	return true;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// AddQuote
inline bool QuoteList::AddQuote (byte* pQuote, unsigned short usQuoteLen)
{
	if (!m_bDataChanged || m_usNE >= MAX_NE)
		return FALSE;

	ExpandBufferIfNeeded(usQuoteLen);
	memcpy (m_pbyData+m_nDataLen, pQuote, usQuoteLen);
	m_nDataLen += usQuoteLen;

	m_usNE++;

	return true;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// ClearData
inline void QuoteList::ClearData()
{
	datatype::ClearData();

	if (m_pDataPosArray)
	{
		delete [] m_pDataPosArray;
		m_pDataPosArray = NULL;
	}
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// GetQuote
inline bool QuoteList::GetQuote (unsigned short nIndex, byte& rLn, short& rFid, byte& rLen, void*& rFv)
{
	if (nIndex >= m_usNE || !m_pDataPosArray || !m_pbyData)
		return false;

	int nThisQuotePos = m_pDataPosArray[nIndex];
	rLn = m_pbyData[nThisQuotePos];
	rFid = * ((short*) (m_pbyData + nThisQuotePos + LENGTHOF_LN));
	rLen = m_pbyData[nThisQuotePos+LENGTHOF_LN_FD];
	rFv = m_pbyData + nThisQuotePos + LENGTHOF_LN_FD_LEN;

	return true;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// GetQuote
inline bool QuoteList::GetQuote (unsigned short nIndex, byte*& rQuote,	unsigned short& rusQuoteLen)
{
	if (nIndex >= m_usNE || !m_pDataPosArray || !m_pbyData)
		return false;

	int nThisQuotePos = m_pDataPosArray[nIndex];
	rQuote = &(m_pbyData[nThisQuotePos]);
	rusQuoteLen = m_pbyData[nThisQuotePos+LENGTHOF_LN_FD] + LENGTHOF_LN_FD_LEN;

	return true;
}


// Class      : QuoteList
// -------------------------------------------------------------------------
// This function will make a LINEAR SEARCH O(n) by byLn and nFid
inline bool QuoteList::GetQuote (byte byLn, short nFid, byte& byLen, void*& pFv)
{
	if (!m_pDataPosArray || !m_pbyData)
		return false;

	byte Ln;
	short Fid;
	byte Len;
	void* Fv;
	for (int i=0; i<m_usNE; i++)
	{
		if (GetQuote (i, Ln, Fid, Len, Fv))
		{
			if (Ln == byLn && Fid == nFid)
			{
				byLen = Len;
				pFv = Fv;
				return true;
			}
		}
	}

	return false;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : MTCTicks
// Description: MTCTicks (Data Type D40)
//
class MTCTicks : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	MTCTicks() : m_HLCArray(NULL), m_HLCArraySize(0), m_HLCArrayAllocated(0),
		m_DoubleByteBuffer(NULL), m_DoubleByteBufferSize(0){};

	~MTCTicks()
	{
		if (m_HLCArray)
			delete [] m_HLCArray;

		if (m_DoubleByteBuffer)
			delete [] m_DoubleByteBuffer;
	};

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MTCTicks(byte* pbyData) : m_HLCArray(NULL), m_HLCArraySize(0), m_HLCArrayAllocated(0),
		m_DoubleByteBuffer(NULL), m_DoubleByteBufferSize(0) {Init(pbyData);}

	enum
	{
		MTC_INVALID_POINT = 0x7FFF,
	};


// Operations
	// -------------------------------------------------------------------------
	// Get the nth Point
	bool GetPoint(short nIndex, short &Open, short &High, short &Low, short &Close);
	
	// -------------------------------------------------------------------------
	// add the Point to the array
	bool AddPoint(short Open, short High, short Low, short Close);

	// -------------------------------------------------------------------------
	// Init the MTCTicks
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);

	// -------------------------------------------------------------------------
	// return the byte stream which H/L/C are all in double byte format
	virtual byte* ToDoubleByteStream();

	// -------------------------------------------------------------------------
	// Init the MTCV by input double byte stream
	virtual bool InitByDoubleByteStream(byte* pbyData);

protected:
	// some contants
	enum
	{
		LENGTHOF_TL = 2,
		LENGTHOF_NE	= 2,
		LENGTHOF_POS = 2,
		LENGTHOF_OPEN = 2,
		LENGTHOF_HIGH = 2,
		LENGTHOF_LOW = 2,
		LENGTHOF_CLOSE = 2,

		LENGTHOF_TL_NE_POS = LENGTHOF_TL + LENGTHOF_NE + LENGTHOF_POS,
		LENGTHOF_OPEN_HIGH = LENGTHOF_OPEN + LENGTHOF_HIGH,
		LENGTHOF_OPEN_HIGH_LOW = LENGTHOF_OPEN + LENGTHOF_HIGH + LENGTHOF_LOW,
		LENGTHOF_OPEN_HIGH_LOW_CLOSE = LENGTHOF_OPEN + LENGTHOF_HIGH + LENGTHOF_LOW + LENGTHOF_CLOSE,

		BUFFER_BLOCK_SIZE = 512,
		MAX_NE = 65535,
	};

	virtual unsigned short GetRepeatedDataLength ()
	{
		return LENGTHOF_OPEN_HIGH_LOW_CLOSE;
	};


	struct HLC
	{
		short	Open;
		short	High;
		short	Low;
		short	Close;
	};

	bool HLCEncode (short hlc, byte* outData, byte& NumOfByte);
	bool HLCDecode (byte* inData, short& hlc, byte& NumOfByte);

	unsigned short SetOHLCToBuffer (short Open, short High, short Low, short Close);

	HLC*				m_HLCArray;
	unsigned short		m_HLCArraySize;
	unsigned short		m_HLCArrayAllocated;

	byte*				m_DoubleByteBuffer;
	unsigned long		m_DoubleByteBufferSize;
};


// Class      : MTCTicks
// -------------------------------------------------------------------------
// GetPoint - start from 0
inline bool MTCTicks::GetPoint(short nIndex, short &Open, short &High, short &Low, short &Close)
{
	if (nIndex < m_unNe)
	{
		Open = m_HLCArray[nIndex].Open;
		High = m_HLCArray[nIndex].High;
		Low = m_HLCArray[nIndex].Low;
		Close = m_HLCArray[nIndex].Close;
		return TRUE;
	}
	else
		return FALSE;
}


// Class      : MTCTicks
// -------------------------------------------------------------------------
// SetOHLCToBuffer
inline unsigned short MTCTicks::SetOHLCToBuffer (short Open, short High, short Low, short Close)
{
	if (m_pbyData == NULL)
	{
		m_nBufferSize = BUFFER_BLOCK_SIZE;
		m_pbyData = new byte[m_nBufferSize];
	}

	byte OpenBuffer[2];
	byte HighBuffer[2];
	byte LowBuffer[2];
	byte CloseBuffer[2];
	byte OpenByte, HighByte, LowByte, CloseByte;
	if (!HLCEncode (Open, OpenBuffer, OpenByte))
		return 0;
	if (!HLCEncode (High, HighBuffer, HighByte))
		return 0;
	if (!HLCEncode (Low, LowBuffer, LowByte))
		return 0;
	if (!HLCEncode (Close, CloseBuffer, CloseByte))
		return 0;

	// check whether it overflows
	if (LENGTHOF_TL_NE_POS + (m_unNe+1) * GetRepeatedDataLength() > m_nBufferSize)
	{
		//Expand the buffer
		unsigned short usOldBufferSize = m_nBufferSize;
		m_nBufferSize += BUFFER_BLOCK_SIZE;
		byte* pNewBuffer = new byte[m_nBufferSize];
		memcpy (pNewBuffer, m_pbyData, usOldBufferSize);
		delete m_pbyData;
		m_pbyData = pNewBuffer;
	}

	// add the data to the buffer stream
	byte* pCurPos = m_pbyData+m_nDataLen;

	memcpy (pCurPos, OpenBuffer, OpenByte);
	pCurPos += OpenByte;
	memcpy (pCurPos, HighBuffer, HighByte);
	pCurPos += HighByte;
	memcpy (pCurPos, LowBuffer, LowByte);
	pCurPos += LowByte;
	memcpy (pCurPos, CloseBuffer, CloseByte);

	return OpenByte + HighByte + LowByte + CloseByte;
}

// Class      : MTCTicks
// -------------------------------------------------------------------------
// AddPoint
inline bool MTCTicks::AddPoint(short Open, short High, short Low, short Close)
{
	if (!m_bDataChanged)
		return FALSE;

	unsigned short hlcLength = SetOHLCToBuffer (Open, High, Low, Close);
	if (hlcLength == 0)
		return FALSE;

	m_nDataLen = m_nDataLen + hlcLength;

	// copy data to m_HLCArray
	if (!m_HLCArray)
	{
		m_HLCArray = new HLC[BUFFER_BLOCK_SIZE];
		m_HLCArrayAllocated = BUFFER_BLOCK_SIZE;
	}

	// check whether it overflows
	if (m_unNe >= m_HLCArrayAllocated)
	{
		// Expand the buffer
		unsigned short oldBufferSize = m_HLCArrayAllocated;
		m_HLCArrayAllocated += BUFFER_BLOCK_SIZE;
		HLC* pNewBuffer = new HLC[m_HLCArrayAllocated];
		for (int i=0; i<oldBufferSize; i++)
			pNewBuffer[i] = m_HLCArray[i];
		delete m_HLCArray;
		m_HLCArray = pNewBuffer;
	}

	// add the data to the buffer stream
	m_HLCArray[m_HLCArraySize].Open = Open;
	m_HLCArray[m_HLCArraySize].High = High;
	m_HLCArray[m_HLCArraySize].Low = Low;
	m_HLCArray[m_HLCArraySize].Close = Close;
	m_HLCArraySize++;

	m_unNe++;
	return TRUE;
}

// Class      : MTCTicks
// -------------------------------------------------------------------------
// Init
inline bool MTCTicks::Init(byte* pbyData)
{
	ClearData();
	m_HLCArraySize = 0;

	if (!pbyData)
		return FALSE;
	unsigned short usTotalNe;
	memcpy(&m_unTL, pbyData, LENGTHOF_TL);
	memcpy(&usTotalNe, pbyData+LENGTHOF_TL, LENGTHOF_NE);
	memcpy(&m_unPos, (pbyData+LENGTHOF_TL+LENGTHOF_NE), LENGTHOF_POS);

	short Open, High, Low, Close;
	byte* pCur = pbyData + LENGTHOF_TL_NE_POS;
	byte NumOfByte;
	for (int i=0; i<usTotalNe; i++)
	{
		if (!HLCDecode (pCur, Open, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!HLCDecode (pCur, High, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!HLCDecode (pCur, Low, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!HLCDecode (pCur, Close, NumOfByte))
			return false;
		pCur += NumOfByte;

		AddPoint (Open, High, Low, Close);
	}

	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short MTCTicks::GetByteLength(byte* pbyData)
{
	unsigned short ne = *(pbyData + LENGTHOF_TL);
	byte* pCur = pbyData + LENGTHOF_TL_NE_POS;
	for (int i = 0; i < ne; i++){ // count ohlc byte len
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += (*pCur & 0x01) ? 2 : 1;
	}
	unsigned short size = pCur - pbyData;
	return size;	
}

// Class      : MTCTicks
// -------------------------------------------------------------------------
// HLCEncode
inline bool MTCTicks::HLCEncode (short hlc, byte* outData, byte& NumOfByte)
{
	if ( (hlc < -16384 || hlc > 16383) && (hlc != MTC_INVALID_POINT) )	// if (it is 16-bit data)
		return false;

	if ( (hlc == MTC_INVALID_POINT) || (hlc >= -63 && hlc <= 63) )		// if (it is 7-bit data)
	{
		if (hlc == MTC_INVALID_POINT)
			hlc = -64;

		byte OneByteData = (byte) ( hlc << 1 );
		NumOfByte = 1;
		memcpy (outData, &OneByteData, 1);
	}
	else
	{
		short TwoByteData = (hlc << 1) | 0x01;
		NumOfByte = 2;
		memcpy (outData, &TwoByteData, 2);
	}

	return true;
}


// Class      : MTCTicks
// -------------------------------------------------------------------------
// HLCDecode
inline bool MTCTicks::HLCDecode (byte* inData, short& hlc, byte& NumOfByte)
{
	if (*inData & 0x01)		// 2 bytes
	{
		memcpy (&hlc, inData, 2);
		NumOfByte = 2;
	}
	else
	{
		hlc = *inData;

		// keep the sign
		hlc <<= 8;
		hlc >>= 8;

		NumOfByte = 1;
	}

	hlc = hlc >> 1;

	if (NumOfByte == 1 && hlc == -64)
		hlc = (short) MTC_INVALID_POINT;

	return true;
}


// Class      : MTCTicks
// -------------------------------------------------------------------------
// ToDoubleByteStream
inline byte* MTCTicks::ToDoubleByteStream()
{
	unsigned long nSize = LENGTHOF_TL_NE_POS + m_HLCArraySize * GetRepeatedDataLength();
	if (nSize > m_DoubleByteBufferSize)
	{
		// resize m_DoubleByteBuffer
		m_DoubleByteBufferSize = nSize;
		if (m_DoubleByteBuffer)
			delete [] m_DoubleByteBuffer;
		m_DoubleByteBuffer = new byte[nSize];
	}

	memcpy(m_DoubleByteBuffer, &m_unTL, LENGTHOF_TL);
	memcpy(m_DoubleByteBuffer+LENGTHOF_TL, &m_unNe, LENGTHOF_NE);
	memcpy((m_DoubleByteBuffer+LENGTHOF_TL+LENGTHOF_NE), &m_unPos, LENGTHOF_POS);

	byte* pCur = m_DoubleByteBuffer + LENGTHOF_TL_NE_POS;
	for (int i=0; i<m_HLCArraySize; i++)
	{
		memcpy (pCur, &( m_HLCArray[i].Open ), LENGTHOF_OPEN);
		memcpy (pCur+LENGTHOF_OPEN, &( m_HLCArray[i].High ), LENGTHOF_HIGH);
		memcpy (pCur+LENGTHOF_OPEN_HIGH, &( m_HLCArray[i].Low ), LENGTHOF_LOW);
		memcpy (pCur+LENGTHOF_OPEN_HIGH_LOW, &( m_HLCArray[i].Close ), LENGTHOF_CLOSE);

		pCur += LENGTHOF_OPEN_HIGH_LOW_CLOSE;
	}

	return m_DoubleByteBuffer;
}


// Class      : MTCTicks
// -------------------------------------------------------------------------
// InitByDoubleByteStream
inline bool MTCTicks::InitByDoubleByteStream(byte* pbyData)
{
	ClearData();
	m_HLCArraySize = 0;

	if (!pbyData)
		return FALSE;
	unsigned short usTotalNe;
	memcpy(&m_unTL, pbyData, LENGTHOF_TL);
	memcpy(&usTotalNe, pbyData+LENGTHOF_TL, LENGTHOF_NE);
	memcpy(&m_unPos, (pbyData+LENGTHOF_TL+LENGTHOF_NE), LENGTHOF_POS);

	short Open, High, Low, Close;
	byte* pCur = pbyData + LENGTHOF_TL_NE_POS;
	for (int i=0; i<usTotalNe; i++)
	{
		memcpy (&Open, pCur, LENGTHOF_OPEN);
		memcpy (&High, pCur+LENGTHOF_OPEN, LENGTHOF_HIGH);
		memcpy (&Low, pCur+LENGTHOF_OPEN_HIGH, LENGTHOF_LOW);
		memcpy (&Close, pCur+LENGTHOF_OPEN_HIGH_LOW, LENGTHOF_CLOSE);
		pCur += LENGTHOF_OPEN_HIGH_LOW_CLOSE;

		AddPoint (Open, High, Low, Close);
	}

	m_bDataChanged = FALSE;
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : MTCV
// Description: MTCV (Data Type D41)
// Protocol	  : <tl><ne><pos>{(<high><low><close><vol>)...}
//
class MTCV : public MTCTicks
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	MTCV() : m_VolArray(NULL), m_VolArrayAllocated(0), m_VolArraySize(0) {};

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MTCV(byte* pbyData) :
		m_VolArray(NULL), m_VolArrayAllocated(0), m_VolArraySize(0) {Init(pbyData);};

	~MTCV()
	{
		if (m_VolArray)
			delete [] m_VolArray;
	};

// Operations
	// -------------------------------------------------------------------------
	// Get the nth Point
	bool GetPoint(short nIndex, short &Open, short &High, short &Low, short &Close, double &Vol);
	
	// -------------------------------------------------------------------------
	// add the Point to the array
	bool AddPoint(short Open, short High, short Low, short Close, double Vol);

	// -------------------------------------------------------------------------
	// Init the MTCV
	bool Init(byte* pbyData);
	//bool Init(byte* pbyData, unsigned int size);
	static unsigned short GetByteLength(byte* pbyData);

	// -------------------------------------------------------------------------
	// return the byte stream which H/L/C are all in double byte format
	byte* ToDoubleByteStream();

	// -------------------------------------------------------------------------
	// Init the MTCV by input double byte stream
	bool InitByDoubleByteStream(byte* pbyData);

protected:
	// some contants
	enum
	{
		LENGTHOF_VOL = 2,

		LENGTHOF_OPEN_HIGH_LOW_CLOSE_VOL = LENGTHOF_OPEN + LENGTHOF_HIGH + LENGTHOF_LOW + LENGTHOF_CLOSE + LENGTHOF_VOL,
	};

	virtual unsigned short GetRepeatedDataLength ()
	{
		return LENGTHOF_OPEN_HIGH_LOW_CLOSE_VOL;
	};

	// make these functions protected
	bool GetPoint(short nIndex, short &Open, short &High, short &Low, short &Close)
	{
		return MTCTicks::GetPoint (nIndex, Open, High, Low, Close);
	};

	bool AddPoint(short Open, short High, short Low, short Close)
	{
		return MTCTicks::AddPoint (Open, High, Low, Close);
	};

	bool VolEncode (double Vol, short& EncodedVol);
	bool VolDecode (short EncodedVol, double& Vol);

	double*				m_VolArray;
	unsigned short		m_VolArraySize;
	unsigned short		m_VolArrayAllocated;
};

// Class      : MTCV
// -------------------------------------------------------------------------
// GetPoint - start from 0
inline bool MTCV::GetPoint(short nIndex, short &Open, short &High, short &Low, short &Close, double &Vol)
{
	if (!GetPoint (nIndex, Open, High, Low, Close))
		return false;

	ASSERT (nIndex < m_VolArraySize);

	Vol = m_VolArray[nIndex];

	return TRUE;
}

// Class      : MTCV
// -------------------------------------------------------------------------
// AddPoint
inline bool MTCV::AddPoint(short Open, short High, short Low, short Close, double Vol)
{
	short EncodedVol;
	if (!VolEncode (Vol, EncodedVol))
		return false;

	if (!AddPoint (Open, High, Low, Close))
		return false;

	byte* pCur = m_pbyData+m_nDataLen;
	memcpy (pCur, &EncodedVol, LENGTHOF_VOL);
	m_nDataLen += LENGTHOF_VOL;

	// copy data to m_HLCArray
	if (!m_VolArray)
	{
		m_VolArray = new double[BUFFER_BLOCK_SIZE];
		m_VolArrayAllocated = BUFFER_BLOCK_SIZE;
	}

	// check whether it overflows
	if (m_unNe >= m_VolArrayAllocated)
	{
		// Expand the buffer
		unsigned short oldBufferSize = m_HLCArrayAllocated;
		m_VolArrayAllocated += BUFFER_BLOCK_SIZE;
		double* pNewBuffer = new double[m_VolArrayAllocated];
		for (int i=0; i<oldBufferSize; i++)
			pNewBuffer[i] = m_VolArray[i];
		delete m_VolArray;
		m_VolArray = pNewBuffer;
	}

	// add the data to the buffer stream
	m_VolArray[m_VolArraySize] = Vol;
	m_VolArraySize++;

	return true;
}

// Class      : MTCV
// -------------------------------------------------------------------------
// Init
inline bool MTCV::Init(byte* pbyData)
{
	// sanity check
	m_HLCArraySize = 0;

	ClearData();
	m_VolArraySize = 0;

	if (!pbyData)
		return FALSE;
	unsigned short usTotalNe;
	memcpy(&m_unTL, pbyData, LENGTHOF_TL);
	memcpy(&usTotalNe, pbyData+LENGTHOF_TL, LENGTHOF_NE);
	memcpy(&m_unPos, (pbyData+LENGTHOF_TL+LENGTHOF_NE), LENGTHOF_POS);

	short Open, High, Low, Close;
	byte* pCur = pbyData + LENGTHOF_TL_NE_POS;
	byte NumOfByte;
	double Vol;
	for (int i=0; i<usTotalNe; i++)
	{
		byte * pPrevCur = pCur;
		if (!HLCDecode (pCur, Open, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!HLCDecode (pCur, High, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!HLCDecode (pCur, Low, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!HLCDecode (pCur, Close, NumOfByte))
			return false;
		pCur += NumOfByte;
		if (!VolDecode (*((short*)pCur), Vol))
			return false;
		pCur += LENGTHOF_VOL;

		AddPoint(Open, High, Low, Close, Vol);
	}

	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short MTCV::GetByteLength(byte* pbyData)
{
	byte * pCur = pbyData + LENGTHOF_TL_NE_POS;
	unsigned short ne = *(pbyData + LENGTHOF_TL);
	for (int i = 0; i < ne; i++)
	{
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += (*pCur & 0x01) ? 2 : 1;
		pCur += LENGTHOF_VOL;
	}
	unsigned short size = pCur - pbyData;
	return size;
}

// Class      : MTCV
// -------------------------------------------------------------------------
// Init
inline bool MTCV::VolEncode (double Vol, short& EncodedVol)
{
	byte Unit = 0;			// 00-0, 01-K, 02-M, 03-B
	double tranVol=0;

	// Should make this "if" to a calculation
	enum
	{
		K = 1000,
		M = 1000000,
		B = 1000000000,
	};

	if (Vol < K)
	{
		Unit = 0;
		tranVol = Vol;
	}
	else if (Vol < M)
	{
		Unit = 1;
		tranVol = Vol / K * 10;
	}
	else if (Vol < B)
	{
		Unit = 2;
		tranVol = Vol / M * 10;
	}
	else if (Vol < 1000000000000.0)
	{
		Unit = 3;
		tranVol = Vol / B * 10;
	}

#pragma warning(suppress: 6001)
	EncodedVol = (((short) tranVol) & 0x3FFF) | (Unit << 14);

	return true;
}

// Class      : MTCV
// -------------------------------------------------------------------------
// Init
inline bool MTCV::VolDecode (short EncodedVol, double& Vol)
{
	byte Unit = (EncodedVol & 0xC000) >> 14;
	double tranVol = (EncodedVol & 0x3FFF);
	if (Unit)
		tranVol /= 10.0;

	Vol = tranVol * pow ((double)1000, Unit);

	return true;
}



// Class      : MTCV
// -------------------------------------------------------------------------
// ToDoubleByteStream
inline byte* MTCV::ToDoubleByteStream()
{
	ASSERT (m_HLCArraySize == m_VolArraySize);

	unsigned long nSize = LENGTHOF_TL_NE_POS + m_HLCArraySize * 16;	// 2+2+2+2+8 = 16
	if (nSize > m_DoubleByteBufferSize)
	{
		// resize m_DoubleByteBuffer
		m_DoubleByteBufferSize = nSize;
		if (m_DoubleByteBuffer)
			delete [] m_DoubleByteBuffer;
		m_DoubleByteBuffer = new byte[nSize];
	}

	memcpy(m_DoubleByteBuffer, &m_unTL, LENGTHOF_TL);
	memcpy(m_DoubleByteBuffer+LENGTHOF_TL, &m_unNe, LENGTHOF_NE);
	memcpy((m_DoubleByteBuffer+LENGTHOF_TL+LENGTHOF_NE), &m_unPos, LENGTHOF_POS);

	byte* pCur = m_DoubleByteBuffer + LENGTHOF_TL_NE_POS;
	for (int i=0; i<m_HLCArraySize; i++)
	{
		memcpy (pCur, &( m_HLCArray[i].Open ), 2);
		memcpy (pCur+LENGTHOF_OPEN, &( m_HLCArray[i].High ), 2);
		memcpy (pCur+LENGTHOF_OPEN_HIGH, &( m_HLCArray[i].Low ), 2);
		memcpy (pCur+LENGTHOF_OPEN_HIGH_LOW, &( m_HLCArray[i].Close ), 2);

		memcpy (pCur+LENGTHOF_OPEN_HIGH_LOW_CLOSE, &( m_VolArray[i] ), 8);

		pCur += 16;
	}

	return m_DoubleByteBuffer;
}


// Class      : MTCV
// -------------------------------------------------------------------------
// InitByDoubleByteStream
inline bool MTCV::InitByDoubleByteStream(byte* pbyData)
{
	ClearData();
	m_HLCArraySize = 0;
	m_VolArraySize = 0;

	if (!pbyData)
		return FALSE;
	unsigned short usTotalNe;
	memcpy(&m_unTL, pbyData, LENGTHOF_TL);
	memcpy(&usTotalNe, pbyData+LENGTHOF_TL, LENGTHOF_NE);
	memcpy(&m_unPos, (pbyData+LENGTHOF_TL+LENGTHOF_NE), LENGTHOF_POS);

	short Open, High, Low, Close;
	double Vol;
	byte* pCur = pbyData + LENGTHOF_TL_NE_POS;
	for (int i=0; i<usTotalNe; i++)
	{
		memcpy (&Open, pCur, 2);
		memcpy (&High, pCur+LENGTHOF_OPEN, 2);
		memcpy (&Low, pCur+LENGTHOF_OPEN_HIGH, 2);
		memcpy (&Close, pCur+LENGTHOF_OPEN_HIGH_LOW, 2);
		pCur += 8;

		Vol = *( (double*) pCur );
		pCur += sizeof(Vol);

		AddPoint (Open, High, Low, Close, Vol);
	}

	m_bDataChanged = FALSE;
	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
//
// Class      : YHeadLine
// Description: YHeadLine (Data Type D42)
//
class YHeadLine : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	YHeadLine():m_plTopicCode(NULL){};

	// -------------------------------------------------------------------------
	// Constructor
	YHeadLine(unsigned long unLn, 
			BDateYear yr, 
			BTimeSec tm, 
			byte byType,
			char* pcLg,
			unsigned long ulPg, 
			char* pcPNAC, 
			char* pcTopicCode, 
			byte byNe,							// 1
			unsigned long *pulPg,				// byNe * 4
			char* pcString);

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	YHeadLine(byte* pbyData):m_plTopicCode(NULL)	{Init(pbyData);}

	// -------------------------------------------------------------------------
	// Default destructor
	~YHeadLine();

// Operations
	// -------------------------------------------------------------------------
	// Get the HeadLine
	bool GetHeadLine(unsigned long &unLn,		// 2
			BDateYear &yr,						// 4
			BTimeSec &tm,						// 2
			byte &byType,						// 1
			char* pcLg,							// 
			unsigned long &ulPg,				// 4
			char* pcPNAC,						// m_byLen2
			char* pcTopicCode,					// unNo*4
			byte &byNe,							// 1
			unsigned long *pulPg,				// byNe*4
			char* pcString);					// byLen;

	// -------------------------------------------------------------------------
	// Init the HeadLine
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);
private:
// attribute
	unsigned short m_unLg;
	long* m_plTopicCode;
	byte m_byNe;
	byte m_byNe2;
	byte m_byLen;
	byte m_byLen2;

// operation
	// -------------------------------------------------------------------------
	// Get the value of char
	byte GetVal(byte byChar);

	// -------------------------------------------------------------------------
	// Encode the 2 bytes and 4 bytes data
	bool Encode(char* pcLg, char* pcTopicCode);

protected:
	// -------------------------------------------------------------------------
	// ClearData
	void ClearData();
};

// Class      : HeadLine
// -------------------------------------------------------------------------
// GetHeadLine - start from 0
inline YHeadLine::~YHeadLine()
{
	ClearData();
}

// Class      : HeadLine
// -------------------------------------------------------------------------
// ClearData
inline void YHeadLine::ClearData()
{
	if (m_pbyData)
	{
		delete [] m_pbyData;
		m_pbyData = NULL;
	}
	if (m_plTopicCode)
	{
		delete [] m_plTopicCode;
		m_plTopicCode = NULL;
	}
}


// Class      : YHeadLine
// -------------------------------------------------------------------------
// Constructor by user input, all the strings must be null-terminated
inline YHeadLine::YHeadLine(unsigned long unLn,	// 4
			BDateYear yr,						// 4
			BTimeSec tm,						// 3
			byte byType,						// 1
			char* pcLg,							// 2
			unsigned long ulPg,					// 4
			char* pcPNAC,						// m_byLen2
			char* pcTopicCode,					// 4*m_byNe + 1
			byte byNe,							// 1
			unsigned long *pulPg,				// byNe * 4
			char* pcString)						// m_byLen+1
{
	m_pbyData = NULL;
	m_nDataLen = 0;

	m_unLg = 0;
	m_plTopicCode = NULL;
	m_byNe = 0;

	// check the string, if no data, do not construct
	if ((!pcLg) || (!pcTopicCode) || (!pcString) || (!pcPNAC))
		return;

	m_byLen2 = strlen(pcPNAC);
//	if (m_byLen2 > 17)
//		return;

	if (!Encode(pcLg, pcTopicCode))
		return;

	m_byLen = strlen(pcString);
	if (m_byLen>255)
		m_byLen = 255;
	m_nDataLen = 4+4+3+1+2+4+1+m_byLen2+m_byNe*4+1+m_byLen+1+byNe*4+1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);

	memcpy(m_pbyData, &unLn, 4);
	memcpy(m_pbyData+4, yr.GetData(), 4);
	memcpy(m_pbyData+8, tm.GetData(), 3);
	memcpy(m_pbyData+11, &byType, 1);
	memcpy(m_pbyData+12, &m_unLg, 2);
	memcpy(m_pbyData+14, &ulPg, 4);
	memcpy(m_pbyData+18, &m_byLen2, 1);
	memcpy(m_pbyData+19, pcPNAC, m_byLen2);
	memcpy(m_pbyData+19+m_byLen2, &m_byNe, 1);
	memcpy(m_pbyData+20+m_byLen2, (byte*)m_plTopicCode, m_byNe*4);
	memcpy(m_pbyData+20+m_byLen2+m_byNe*4, &byNe, 1);
	memcpy(m_pbyData+21+m_byLen2+m_byNe*4, pulPg, byNe*4);
	memcpy(m_pbyData+21+m_byLen2+m_byNe*4+byNe*4, &m_byLen, 1);
	memcpy(m_pbyData+22+m_byLen2+m_byNe*4+byNe*4, pcString, m_byLen);
}


// Class      : YHeadLine
// -------------------------------------------------------------------------
// GetYHeadLine
inline bool YHeadLine::GetHeadLine(unsigned long &unLn,		// 2
			BDateYear &yr,									// 4
			BTimeSec &tm,									// 2
			byte &byType,									// 1
			char* pcLg,										// 
			unsigned long &ulPg,							// 4
			char* pcPNAC,									// byLen2
			char* pcTopicCode,								// unNo*4
			byte &byNe,										// 1
			unsigned long *pulPg,							// byNe*4
			char* pcString)									// byLen
{
	if (!m_pbyData)
		return FALSE;

	char cCharArray[34] = "0ABCDEFGHIJKLMNOPQRSTUVWXYZ /\\.=";
	memcpy(&unLn, m_pbyData, 4);
	yr.Init(m_pbyData+4);
	tm.Init(m_pbyData+8);
	memcpy(&byType, m_pbyData+11, 1);
	// decode the language ID
	memcpy(&m_unLg, m_pbyData+12, 2);
	byte byChar = 0;
	for(int i = 0; i<3; i++)
	{
		byChar = cCharArray[(byte) ((m_unLg >> (16-(i+1)*5)) & 0x1F)];
		if (byChar != '0')
			*(pcLg+i) = byChar;
	}

	memcpy(&ulPg, m_pbyData+14, 4);
	memcpy(&m_byLen2, m_pbyData+18, 1);
	memcpy(pcPNAC, m_pbyData+19, m_byLen2);
	pcPNAC[m_byLen2] = 0;
	memcpy(&m_byNe, m_pbyData+19+m_byLen2, 1);
	// decode the topic code
	if (!m_plTopicCode)
		m_plTopicCode = new long[m_byNe];
	memset(m_plTopicCode, 0, m_byNe*4);
	memcpy((byte*) m_plTopicCode, m_pbyData+20+m_byLen2, m_byNe*4);
	long tmpTopicCode = 0;
	int counter;
	int j = 0;
	for(int i = 0; i<m_byNe; i++)
	{
		tmpTopicCode = *(m_plTopicCode+i);
		for(counter = 1; counter < 7; counter++) 
		{
			byChar = cCharArray[(byte) ((tmpTopicCode >> (32-counter*5)) & 0x1F)];
			if (byChar != '0')
			{
				*(pcTopicCode+j) = byChar;
				j++;
			}
		}
		if (i+1 < m_byNe)
		{
			*(pcTopicCode + j) = ' ';
			j++;
		}
	}

	// Get the ne1 of page no.
	memcpy(&byNe, m_pbyData+20+m_byLen2+m_byNe*4, 1);
	memcpy(pulPg, m_pbyData+21+m_byLen2+m_byNe*4, byNe*4);
	memcpy(&m_byLen, m_pbyData+21+m_byLen2+m_byNe*4+byNe*4, 1);
	memcpy(pcString, m_pbyData+22+m_byLen2+m_byNe*4+byNe*4, m_byLen);
	return TRUE;
}

// Class      : YHeadLine
// -------------------------------------------------------------------------
// Init
inline bool YHeadLine::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;

	m_plTopicCode = NULL;
	memcpy(&m_byLen2, pbyData+18, 1);
	memcpy(&m_byNe, pbyData+19+m_byLen2, 1);
	memcpy(&m_byNe2, pbyData+20+m_byNe*4+m_byLen2, 1);
	m_nDataLen = 21+m_byNe*4+m_byNe2*4+m_byLen2;
	m_nDataLen = m_nDataLen + *(pbyData+m_nDataLen) + 1;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short YHeadLine::GetByteLength(byte* pbyData)
{
	byte byLen2, byNe, byNe2;
	memcpy(&byLen2, pbyData + 18, 1);
	memcpy(&byNe, pbyData + 19 + byLen2, 1);
	memcpy(&byNe2, pbyData + 20 + byNe * 4 + byLen2, 1);
	unsigned short size = 21 + byNe * 4 + byNe2 * 4 + byLen2;
	size = size + *(pbyData + size) + 1;
	return size;

}

// Class      : YHeadLine
// -------------------------------------------------------------------------
// GetVal
inline byte YHeadLine::GetVal(byte byChar)
{
	byte byVal = 0;
	// 1234567890123456789012345678901
	// ABCDEFGHIJKLMNOPQRSTUVWXYZ /\.=
	if (byChar >= 'A' && byChar <= 'Z')
		byVal = byChar - 'A' + 1;
	else if (byChar == ' ')
		byVal = 27;
	else if (byChar == '/')
		byVal = 28;
	else if (byChar == '\\')
		byVal = 29;
	else if (byChar == '.')
		byVal = 30;
	else if (byChar == '=')
		byVal = 31;
	else
		byVal = 0;

	return byVal;
}

// Class      : YHeadLine
// -------------------------------------------------------------------------
// Encode
inline bool YHeadLine::Encode(char* pcLg, char* pcTopicCode)
{
	short nStrLen = 0;
	// Generate the Language ID
	nStrLen = strlen(pcLg);
	if (nStrLen > 3)
		nStrLen = 3;
	for(int i = 0; i < nStrLen; i++)
		m_unLg = m_unLg + ( ((unsigned short) GetVal(*(pcLg+i))) << (16-5*(i+1)) );

	// Generate the TopicCode Array
	int counter = 1;
	unsigned long tmpTopicCode = 0;

	nStrLen = strlen(pcTopicCode);
	if (nStrLen > 255)
		nStrLen = 255;
	m_plTopicCode = new long[nStrLen];
	memset(m_plTopicCode, 0, 4*nStrLen);
	for(int i = 0; i<nStrLen+1; i++)
	{
		if ((*(pcTopicCode+i) != ' ') && (*(pcTopicCode+i) != 0))
		{
			if (counter+1 > 7)
				return FALSE;
			tmpTopicCode = tmpTopicCode + (((unsigned long) GetVal(*(pcTopicCode+i))) << (32-5*counter));
			counter++;
		}
		else
		{
			if (tmpTopicCode != 0)
			{
				*(m_plTopicCode+m_byNe) = tmpTopicCode;
				tmpTopicCode = 0;
				m_byNe++;
			}
			counter = 1;
		}
	}

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
//
// Class      : OBkrQue
// Description: OBkrQue (Data Type D43)
//
class OBkrQue : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	OBkrQue():m_byNe(0), m_pnPosArray(NULL){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor by byte Stream
	OBkrQue(byte* pbyData):m_byNe(0), m_pnPosArray(NULL){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Constructor by byte Stream
	~OBkrQue();

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth A
	bool GetBroker(short nIndex, byte &byA, unsigned short &unB, unsigned short &unC, unsigned long &ulOSN);

	// -------------------------------------------------------------------------
	// Add Broker to the array
	bool AddBroker(byte byA, unsigned short unB, unsigned short unC, unsigned long ulOSN);

	// -------------------------------------------------------------------------
	// Init the OBkrQue
	bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);
	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

private:
// Attributes
	byte	m_byNe;
	short	*m_pnPosArray;

protected:
// Operation
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();
};

// Class      : OBkrQue
// -------------------------------------------------------------------------
// Destructor
inline OBkrQue::~OBkrQue()
{
	ClearData();
}

// Class      : OBkrQue
// -------------------------------------------------------------------------
// ClearData
inline void OBkrQue::ClearData()
{
	if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}
	if (m_pnPosArray)
	{
		delete[] m_pnPosArray;
		m_pnPosArray = NULL;
	}
}

// Class      : OBkrQue
// -------------------------------------------------------------------------
// GetBroker - start from 0
inline bool OBkrQue::GetBroker(short nIndex, byte &byA, unsigned short &unB, unsigned short &unC, unsigned long &ulOSN)
{
	if (nIndex < m_byNe)
	{
		memcpy(&unB, (m_pbyData+*(m_pnPosArray+nIndex)), 2);
		byA = (byte) ((unB & 0xC000) >> 14);
		unB = unB & 0x3FFF;
		unC = 0;
		if (byA==3)
		{
			memcpy(&unC, (m_pbyData+*(m_pnPosArray+nIndex)+2), 2);
			memcpy(&ulOSN, (m_pbyData+*(m_pnPosArray+nIndex)+4), 4);
		}
		else
			memcpy(&ulOSN, (m_pbyData+*(m_pnPosArray+nIndex)+2), 4);

		return TRUE;
	}
	else
		return FALSE;
}

// Class      : OBkrQue
// -------------------------------------------------------------------------
// AddUFloat
inline bool OBkrQue::AddBroker(byte byA, unsigned short unB, unsigned short unC, unsigned long ulOSN)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
		m_pnPosArray = new short[256];
		memset(m_pnPosArray, 0, 256);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 256)
		return FALSE;

	if (byA == 3)
	{
		if (m_nDataLen + 8>=1024)
			return FALSE;
	}
	else
	{
		if (m_nDataLen + 6>=1024)
			return FALSE;
	}

	// add the data to the buffer stream
	unsigned short unAB = byA;
	unAB = (unAB<<14) | unB;

	memcpy(m_pbyData+m_nDataLen, &unAB, 2);
	if (byA == 3)
	{
		memcpy(m_pbyData+m_nDataLen+2, &unC, 2);
		memcpy(m_pbyData+m_nDataLen+4, &ulOSN, 4);
		m_nDataLen = m_nDataLen + 8;
	}
	else
	{
		memcpy(m_pbyData+m_nDataLen+2, &ulOSN, 4);
		m_nDataLen = m_nDataLen + 6;
	}
	*(m_pbyData) = m_byNe = m_byNe + 1;
	*(m_pnPosArray+m_byNe) = m_nDataLen;
	return TRUE;
}

// Class      : OBkrQue
// -------------------------------------------------------------------------
// Init
inline bool OBkrQue::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	if (!m_pnPosArray)
	{
		m_pnPosArray = new short[m_byNe];
		memset(m_pnPosArray, 0, 2*m_byNe);
	}
	byte byA = 0;
	m_nDataLen = 1;
	for (int i=0; i<m_byNe; i++)
	{
		*(m_pnPosArray+i) = m_nDataLen;
		byA = (byte) ((*((short*)(pbyData+m_nDataLen)) & 0xC000) >> 14);
		if (byA == 3)
			m_nDataLen = m_nDataLen+8;
		else
			m_nDataLen = m_nDataLen+6;
	}
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short OBkrQue::GetByteLength(byte* pbyData)
{
	unsigned short size = 1;
	byte ne = *pbyData;
	for (int i = 0; i < ne; i++)
	{
		byte byA = (byte)((*((short*)(pbyData + size)) & 0xC000) >> 14);
		size += byA == 3 ? 8 : 6;
	}
	return size;
}

// Class      : OBkrQue
// -------------------------------------------------------------------------
// GetData
inline byte* OBkrQue::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];
	
	*(m_pbyData) = m_byNe;
	return m_pbyData;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : BQueVOSN
// Description: BQueVOSN (Data Type D46)
//
class BQueVOSN : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	BQueVOSN():m_byNe(0), m_pnPosArray(NULL){m_nDataLen = 1;}

	// -------------------------------------------------------------------------
	// Constructor by byte Stream
	BQueVOSN(byte* pbyData):m_byNe(0), m_pnPosArray(NULL){Init(pbyData);}

	// -------------------------------------------------------------------------
	// Constructor by byte Stream
	inline ~BQueVOSN();

// Operations
	// -------------------------------------------------------------------------
	// Get the number of element
	inline byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth A
	inline bool GetBroker(short nIndex, byte &byA, unsigned short &unB, unsigned short &unC, unsigned long &ulOSN);

	// -------------------------------------------------------------------------
	// Add Broker to the array
	inline bool AddBroker(byte byA, unsigned short unB, unsigned short unC, unsigned long ulOSN);

	// -------------------------------------------------------------------------
	// Init the OBkrQue
	inline bool Init(byte* pbyData);
	static unsigned short GetByteLength(byte* pbyData);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

private:
// Attributes
	byte	m_byNe;
	short	*m_pnPosArray;

protected:
// Operation
	// -------------------------------------------------------------------------
	// Clear Memory
	void ClearData();
};

// Class      : BQueVOSN
// -------------------------------------------------------------------------
// Destructor
inline BQueVOSN::~BQueVOSN()
{
	ClearData();
}

// Class      : BQueVOSN
// -------------------------------------------------------------------------
// ClearData
inline void BQueVOSN::ClearData()
{
	if (m_pbyData)
	{
		delete[] m_pbyData;
		m_pbyData = NULL;
	}
	if (m_pnPosArray)
	{
		delete[] m_pnPosArray;
		m_pnPosArray = NULL;
	}
}

// Class      : BQueVOSN
// -------------------------------------------------------------------------
// GetBroker - start from 0
inline bool BQueVOSN::GetBroker(short nIndex, byte &byA, unsigned short &unB, unsigned short &unC, unsigned long &ulOSN)
{
	if (nIndex < m_byNe)
	{
		memcpy(&unB, (m_pbyData+*(m_pnPosArray+nIndex)), 2);
		byA = (byte) ((unB & 0xC000) >> 14);
		unB = unB & 0x3FFF;
		unC = 0;
        ulOSN = 0;
        unsigned long ulType;
        byte* addrType = (unsigned char*)&ulType;
        byte* addrOSN = (unsigned char*)&ulOSN;
		if (byA==3)
		{
			memcpy(&unC, (m_pbyData+*(m_pnPosArray+nIndex)+2), 2);
			memcpy(addrType + 3, (m_pbyData+*(m_pnPosArray+nIndex)+4), 1);
            ulType = (ulType & 0xC0000000) >> 30;
            for (unsigned long l=0; l<(ulType+1); l++)
                *(addrOSN+3-l) = *(m_pbyData+*(m_pnPosArray+nIndex)+4+l);
		}
		else
        {
			memcpy(addrType + 3, (m_pbyData+*(m_pnPosArray+nIndex)+2), 1);
            ulType = (ulType & 0xC0000000) >> 30;
            for (unsigned long l=0; l<(ulType+1); l++)
                *(addrOSN+3-l) = *(m_pbyData+*(m_pnPosArray+nIndex)+2+l);
        }
        ulOSN = (ulOSN&0x3FFFFFFF) >> (24 - 8 * ulType);

		return TRUE;
	}
	else
		return FALSE;
}

// Class      : BQueVOSN
// -------------------------------------------------------------------------
// AddUFloat
inline bool BQueVOSN::AddBroker(byte byA, unsigned short unB, unsigned short unC, unsigned long ulOSN)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_nBufferSize = 1024;
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
		m_pnPosArray = new short[256];
		memset(m_pnPosArray, 0, 256);
	}

	// check whether it overflow the limit
	unsigned short unAB = byA;
	unAB = (unAB<<14) | unB;

    unsigned long ulType;
    if (ulOSN <= 0x3F)
        ulType = 0;
    else if (ulOSN <= 0x3FFF)
        ulType = 1;
    else if (ulOSN <= 0x3FFFFF)
        ulType = 2;
    else if (ulOSN <= 0x3FFFFFFF)
        ulType = 3;
    else
        return FALSE;
    ulOSN = (ulType << 30)|(ulOSN << (24 - 8 * ulType));
	if (m_byNe + 1 > 256)
		return FALSE;

	if (byA == 3)
	{
		if (m_nDataLen + 4 + (int)ulType + 1 >=1024)
			return FALSE;
	}
	else
	{
		if (m_nDataLen + 2 + (int)ulType + 1 >=1024)
			return FALSE;
	}

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &unAB, 2);
    byte* addr = (unsigned char*)&ulOSN;
	if (byA == 3)
	{
		memcpy(m_pbyData+m_nDataLen+2, &unC, 2);
        for (unsigned long l=0; l<(ulType+1); l++)
            *(m_pbyData+m_nDataLen+4+l) = *(addr+3-l);
		m_nDataLen = m_nDataLen + 4 + (int)ulType + 1;
	}
	else
	{
        for (unsigned long l=0; l<(ulType+1); l++)
            *(m_pbyData+m_nDataLen+2+l) = *(addr+3-l);
		m_nDataLen = m_nDataLen + 2 + (int)ulType + 1;
	}
	*(m_pbyData) = m_byNe = m_byNe + 1;
	*(m_pnPosArray+m_byNe) = m_nDataLen;
	return TRUE;
}

// Class      : BQueVOSN
// -------------------------------------------------------------------------
// Init
inline bool BQueVOSN::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	m_byNe = *pbyData;
	if (!m_pnPosArray)
	{
		m_pnPosArray = new short[m_byNe];
		memset(m_pnPosArray, 0, 2*m_byNe);
	}
	byte byA = 0;
    unsigned char ucType;

	m_nDataLen = 1;
	for (int i=0; i<m_byNe; i++)
	{
		*(m_pnPosArray+i) = m_nDataLen;
		byA = (byte) ((*((short*)(pbyData+m_nDataLen)) & 0xC000) >> 14);
		if (byA == 3)
        {
            ucType = (unsigned char) ((*((unsigned char*)(pbyData+m_nDataLen+4)) & 0xC0) >> 6);
			m_nDataLen = m_nDataLen+4+ucType+1;
        }
		else
        {
            ucType = (unsigned char) ((*((unsigned char*)(pbyData+m_nDataLen+2)) & 0xC0) >> 6);
			m_nDataLen = m_nDataLen+2+ucType+1;
        }
	}
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}

inline unsigned short BQueVOSN::GetByteLength(byte* pbyData)
{
	byte ne = *pbyData;
	unsigned short size = 1;

	for (int i = 0; i < ne; i++)
	{
		byte byA = (byte)((*((short*)(pbyData + size)) & 0xC000) >> 14);

		unsigned char ucType = (unsigned char)((*((unsigned char*)(pbyData + size + (byA == 3 ? 4:2))) & 0xC0) >> 6);
		size += (byA == 3 ? 4 : 2) + ucType + 1;
	}
	return size;
}

// Class      : BQueVOSN
// -------------------------------------------------------------------------
// GetData
inline byte* BQueVOSN::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];
	
	*(m_pbyData) = m_byNe;
	return m_pbyData;
}







/////////////////////////////////////////////////////////////////////////////
//
// Class      : MTCPTS
// Description: MTCPTS (Data Type D47)
//
class MTCPTS : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
    MTCPTS(){m_nBufferSize = 6;};

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MTCPTS(byte* pbyData){Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the nth Point
	bool GetPoint(short nIndex, byte &byPoint);
	
	// -------------------------------------------------------------------------
	// add the Point to the array
	bool AddPoint(byte byPoint);

	// -------------------------------------------------------------------------
	// Init the MTCPTS
	bool Init(byte* pbyData);
};

// Class      : MTCPTS
// -------------------------------------------------------------------------
// GetPoint - start from 0
inline bool MTCPTS::GetPoint(short nIndex, byte &byPoint)
{
	if (nIndex < m_unNe)
	{
		byPoint = *(m_pbyData+6+nIndex);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : MTCPTS
// -------------------------------------------------------------------------
// AddPoint
inline bool MTCPTS::AddPoint(byte byPoint)
{
	if (!m_bDataChanged)
		return FALSE;

    if (m_unNe == SHRT_MAX)
        return FALSE;

    if (m_nBufferSize-6 < m_unNe+1)
    {
        int nNewSize = m_nBufferSize + 256;
        byte *pNew = new byte[nNewSize];
        memset(pNew, 0, nNewSize);
        if (m_pbyData != NULL)
        {
            memcpy(pNew, m_pbyData, m_nBufferSize);
            delete [] m_pbyData;
        }
        m_pbyData = pNew;
        m_nBufferSize = nNewSize;
    }

	// add the data to the buffer stream
	*(m_pbyData+m_nDataLen) = byPoint;

	m_nDataLen = m_nDataLen + 1;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : MTCPTS
// -------------------------------------------------------------------------
// Init
inline bool MTCPTS::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, (pbyData+4), 2);
	m_nDataLen = m_unNe+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}








/////////////////////////////////////////////////////////////////////////////
//
// Class      : MTCF
// Description: MTCF (Data Type D48)
//
class MTCF : public Base
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
    MTCF(){m_nBufferSize = 6;};

	// -------------------------------------------------------------------------
	// Constructor - by Input string
	MTCF(byte* pbyData){Init(pbyData);}

	enum
	{
		MTCF_INVALID_POINT = -1,
	};

// Operations
	// -------------------------------------------------------------------------
	// Get the nth Point
	bool GetPoint(short nIndex, float &Open, float &High, float &Low, float &Close, double &Vol);
	
	// -------------------------------------------------------------------------
	// add the Point to the array
	bool AddPoint(float Open, float High, float Low, float Close, double Vol);

	// -------------------------------------------------------------------------
	// Init the MTCF
	bool Init(byte* pbyData);
};

// Class      : MTCF
// -------------------------------------------------------------------------
// GetPoint - start from 0
inline bool MTCF::GetPoint(short nIndex, float &Open, float &High, float &Low, float &Close, double &Vol)
{
	if (nIndex < m_unNe)
	{
		memcpy(&Open, (m_pbyData+6+nIndex*24), 4);
		memcpy(&High, (m_pbyData+10+nIndex*24), 4);
		memcpy(&Low, (m_pbyData+14+nIndex*24), 4);
		memcpy(&Close, (m_pbyData+18+nIndex*24), 4);
		memcpy(&Vol, (m_pbyData+22+nIndex*24), 8);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : MTCF
// -------------------------------------------------------------------------
// AddPoint
inline bool MTCF::AddPoint(float Open, float High, float Low, float Close, double Vol)
{
	if (!m_bDataChanged)
		return FALSE;

    if (m_unNe == SHRT_MAX)
        return FALSE;

    if (m_nBufferSize-6 < (m_unNe+1)*24)
    {
        int nNewSize = m_nBufferSize + 256;
        byte *pNew = new byte[nNewSize];
        memset(pNew, 0, nNewSize);
        if (m_pbyData != NULL)
        {
            memcpy(pNew, m_pbyData, m_nBufferSize);
            delete [] m_pbyData;
        }
        m_pbyData = pNew;
        m_nBufferSize = nNewSize;
    }


	// add the data to the buffer stream
	memcpy((m_pbyData+m_nDataLen), &Open, 4);
	memcpy((m_pbyData+m_nDataLen+4), &High, 4);
	memcpy((m_pbyData+m_nDataLen+8), &Low, 4);
	memcpy((m_pbyData+m_nDataLen+12), &Close, 4);
	memcpy((m_pbyData+m_nDataLen+16), &Vol, 8);

	m_nDataLen = m_nDataLen + 24;
	m_unNe = m_unNe + 1;
	return TRUE;
}

// Class      : MTCF
// -------------------------------------------------------------------------
// Init
inline bool MTCF::Init(byte* pbyData)
{
	ClearData();
	if (!pbyData)
		return FALSE;
	memcpy(&m_unTL, pbyData, 2);
	memcpy(&m_unNe, pbyData+2, 2);
	memcpy(&m_unPos, (pbyData+4), 2);
	m_nDataLen = m_unNe*24+6;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
//
// Class      : TranD
// Description: Data Type D51
//
class TranD : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	TranD();

	// -------------------------------------------------------------------------
	// Constructor - construct the Tran by data stream
	TranD(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the Number of Element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the nth element of the array
	bool GetTranElement(short nIndex, unsigned long &ulSq,
						BTimeSec &Tm,
						double &dVl,
						float &fNm,
						byte &byFg);

	// -------------------------------------------------------------------------
	// Add an element to the Tran
	bool AddTranElement(unsigned long ulSq, 
						BTimeSec Tm,
						double dVl,
						float fNm,
						byte byFg);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the Tran
	bool Init(byte* pbyData);

private:
// Attributes
	byte			m_byNe;
};

// Class      : TranD
// -------------------------------------------------------------------------
// Default constructor
inline TranD::TranD()
{
	m_nDataLen = 1;
	m_nBufferSize = 402;
	m_byNe = 0;
}

// Class      : TranD
// -------------------------------------------------------------------------
// Init Tran
inline bool TranD::Init(byte* pbyData)
{
	ClearData();
	if (pbyData == 0) 
		return FALSE;

	m_byNe = *pbyData;

	m_nDataLen = 1+m_byNe*20;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);

	m_byNe = *m_pbyData;
	m_bDataChanged = FALSE;
	return (m_pbyData != 0);
}

// Class      : TranD
// -------------------------------------------------------------------------
// AddTranElement
inline bool TranD::AddTranElement(unsigned long ulSq, 
						BTimeSec Tm,
						double dVl,
						float fNm,
						byte byFg)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 20)
		return FALSE;

	// add the data to the buffer stream
	memcpy(m_pbyData+m_nDataLen, &ulSq, 4);
	if (Tm.GetData())
		memcpy(m_pbyData+m_nDataLen+4, Tm.GetData(), 3);
	memcpy(m_pbyData+m_nDataLen+7, &dVl, 8);
	memcpy(m_pbyData+m_nDataLen+15, &fNm, 4);
	memcpy(m_pbyData+m_nDataLen+19, &byFg, 1);

	m_nDataLen = m_nDataLen + 20;
	m_byNe = m_byNe + 1;
	return TRUE;
}


// Class      : TranD
// -------------------------------------------------------------------------
// GetTranElement - start from 0
inline bool TranD::GetTranElement(short nIndex, unsigned long &ulSq,
						BTimeSec &Tm,
						double &dVl,
						float &fNm,
						byte &byFg)
{
	if (nIndex < m_byNe)
	{
		memcpy(&ulSq, (m_pbyData+1+20*nIndex), 4);
		Tm.Init((m_pbyData+5+20*nIndex));
		memcpy(&dVl, (m_pbyData+8+20*nIndex), 8);
		memcpy(&fNm, (m_pbyData+16+20*nIndex), 4);
		memcpy(&byFg, (m_pbyData+20+20*nIndex), 1);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : TranD
// -------------------------------------------------------------------------
// GetData
inline byte* TranD::GetData()
{
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	*m_pbyData = m_byNe;
	return m_pbyData;
}

/////////////////////////////////////////////////////////////////////////////
//
// Class      : TxnD
// Description: Data Type D52
//
class TxnD : public datatype
{
public:
	// -------------------------------------------------------------------------
	// Default Constructor
	TxnD();

	// -------------------------------------------------------------------------
	// Constructor - construct the Txn by data stream
	TxnD(byte* pbyData)	{Init(pbyData);}

// Operations
	// -------------------------------------------------------------------------
	// Get the total line
	unsigned long GetTL()	{return m_ulTL;}

	// -------------------------------------------------------------------------
	// Get the Number of Element
	byte GetNe()	{return m_byNe;}

	// -------------------------------------------------------------------------
	// Get the Sequence Number
	unsigned long GetSq()	{return m_ulSq;}

	// -------------------------------------------------------------------------
	// Get the nth element of the array
	bool GetTranElement(short nIndex, 
						BTimeSec &Tm,
						double &dVl,
						float &fNm,
						byte &byFg);

	// -------------------------------------------------------------------------
	// Set the total line
	void SetTL(unsigned long ulTL) { m_ulTL = ulTL; }

	// -------------------------------------------------------------------------
	// Set the Sequence number
	void SetSq(unsigned long ulSq) { m_ulSq = ulSq; }

	// -------------------------------------------------------------------------
	// Add an element to the TxnD
	bool AddTranElement(BTimeSec Tm,
						double dVl,
						float fNm,
						byte byFg);

	// -------------------------------------------------------------------------
	// Get the Data
	byte* GetData();

	// -------------------------------------------------------------------------
	// Init the TxnD
	bool Init(byte* pbyData);

private:
// Attributes
	unsigned long	m_ulTL;
	byte			m_byNe;
	unsigned long	m_ulSq;
};

// Class      : TxnD
// -------------------------------------------------------------------------
// Default constructor
inline TxnD::TxnD()
{
	m_nDataLen = 9;
	m_nBufferSize = 330;
	m_ulTL = 0;
	m_byNe = 0;
	m_ulSq = 0;
}

// Class      : TxnD
// -------------------------------------------------------------------------
// Init Txn
inline bool TxnD::Init(byte* pbyData)
{
	ClearData();
	if (pbyData == 0) 
		return FALSE;

	memcpy(&m_ulTL, pbyData, 4);
	m_byNe = *(pbyData+4);
	memcpy(&m_ulSq, pbyData+5, 4);

	m_nDataLen = 9+m_byNe*16;
	m_pbyData = new byte[m_nDataLen+1];
	memset(m_pbyData, 0, m_nDataLen+1);
	memcpy(m_pbyData, pbyData, m_nDataLen);
	m_bDataChanged = FALSE;
	return (m_pbyData != 0);
}

// Class      : TxnD
// -------------------------------------------------------------------------
// AddTranElement
inline bool TxnD::AddTranElement(BTimeSec Tm,
						double dVl,
						float fNm,
						byte byFg)
{
	if (!m_bDataChanged)
		return FALSE;

	if (m_pbyData == NULL)
	{
		m_pbyData = new byte[m_nBufferSize];
		memset(m_pbyData, 0, m_nBufferSize);
	}

	// check whether it overflow the limit
	if (m_byNe + 1 > 20)
		return FALSE;

	// add the data to the buffer stream
	if (Tm.GetData())
		memcpy(m_pbyData+m_nDataLen, Tm.GetData(), 3);
	memcpy(m_pbyData+m_nDataLen+3, &dVl, 8);
	memcpy(m_pbyData+m_nDataLen+11, &fNm, 4);
	memcpy(m_pbyData+m_nDataLen+15, &byFg, 1);

	m_nDataLen = m_nDataLen + 16;
	m_byNe = m_byNe + 1;
	return TRUE;
}

// Class      : TxnD
// -------------------------------------------------------------------------
// GetTranElement - start from 0
inline bool TxnD::GetTranElement(short nIndex, 
						BTimeSec &Tm,
						double &dVl,
						float &fNm,
						byte &byFg)
{
	if (nIndex < m_byNe)
	{
		Tm.Init((m_pbyData+9+16*nIndex));
		memcpy(&dVl, (m_pbyData+12+16*nIndex), 8);
		memcpy(&fNm, (m_pbyData+20+16*nIndex), 4);
		memcpy(&byFg, (m_pbyData+24+16*nIndex), 1);
		return TRUE;
	}
	else
		return FALSE;
}

// Class      : TxnD
// -------------------------------------------------------------------------
// GetData
inline byte* TxnD::GetData()
{
	ASSERT(m_ulTL >= m_byNe + m_ulSq);
	ASSERT(m_ulTL > 0);
	ASSERT(m_byNe > 0);
	if (!m_pbyData)
		m_pbyData = new byte[m_nDataLen];

	memcpy(m_pbyData, &m_ulTL, 4);
	*(m_pbyData+4) = m_byNe;
	memcpy(m_pbyData+5, &m_ulSq, 4);
	return m_pbyData;
}

}

#endif
